phc-discussions - Re: [PHC] RE: Password hashing as a self-overwriting Turing machine

Message-ID: <1794334685-4008@skroderider.denisbider.com>
Date: Wed, 1 Jul 2015 21:48:52 +0100
From: denis bider <pwhashing@...isbider.com>
To: discussions@...sword-hashing.net
Subject: Re: [PHC] RE: Password hashing as a self-overwriting Turing machine



What  is the basis for your claim that a randomized sequence of operations  from the set you have chosen results in a irreducible function? Unfortunately, I don't have the background to properly answer this formally. This is where I think someone else, if they were interested, could contribute. To me, this seems "obvious" and "plain" - but there is "seeing" that 1 + 1 = 2, and then there's Russell & Whitehead investing 300 pages to prove it.


Marsh Ray <maray@...rosoft.com, 7/1/2015 9:15 PM:
   

Denis Bider: 

I consider formal proof a nice thing to have, but less than crucial. 

We don't have formal proof for ECC, DH, or RSA, either. 

  

The difference is that those functions are provably equivalent to problems that are known very hard. Problems that mathematicians have in some cases spent a century  studying. 

  

What is the basis for your claim that a randomized sequence of operations from the set you have chosen results in a irreducible function? 

  

I'm not suggesting you can't come up with a good answer for this. I'm just saying I think this is the place to start with further analysis of your function. 

  

Focusing solely on formal proof seems to me like the case of 

building a fence around a house where most of the planks are 

six feet, but one of the planks is sky-high. 

  

Don't worry, we're all very practically minded here. 

  

I did not use AES because I wanted something in portable C++ (CPU AES 

would require assembly), and also - we cannot yet count on CPU AES 

support in the platforms we target. 

  

Actually, I do agree with you on this. 

  

If you don't have CPU AES support, then the way I see it, if you rely 

solely on AES, you're spending proportionally more time operating 

on small blocks of data, instead of exercising what the CPU does 

well, which is fetching stuff from memory. 

  

I think you would enjoy reading through the list archives. Topics such as this are discussed in considerable depth. 

  

- Marsh 

   


