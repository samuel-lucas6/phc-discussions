<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] Bandwidth hardened algorithms?</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="../../../2015/07/11/1">[&lt;prev]</a> <a href="2">[next&gt;]</a> <a href="../../../2015/07/11/1">[&lt;thread-prev]</a> <a href="4">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CALW8-7+p0jNeCajhJRa6oWvHnCR9PyZymafiqPQ4C36j4UMrHQ&#64;mail.gmail.com&gt;
Date: Mon, 13 Jul 2015 19:56:21 +0200
From: Dmitry Khovratovich &lt;khovratovich&#64;...il.com&gt;
To: "discussions&#64;...sword-hashing.net" &lt;discussions&#64;...sword-hashing.net&gt;
Cc: John Tromp &lt;john.tromp&#64;...il.com&gt;
Subject: Re: [PHC] Bandwidth hardened algorithms?

Hi Bill,

As I understand you deal with the attacks that require a lot of bandwidth
if run in parallel. This is the same effect that we encountered in our
tradeoff attacks, where I remember your bandwidth-related critique.

I think both bandwidth- and memory- hardening fit into more generalized
framework of cost-hardening, where we want to lower bound the ASIC running
costs. We already have a good/standard metric for the cost --- it is the
time-area product (AT). Costs of many parallel algorithms have been
evaluated in this metrics, and we know how to compare them.

In the AT metric both memory and bandwidth are related to the area. Area
grows linearly with the memory. On the other hand, in the 2D view,
bandwidth is probably proportional to the area as well. At least, it is
easy to imagine a twice larger chip that has double bandwidth. Similarly to
counting how much memory fits into a mm^2, we could count how much
bandwidth a 1-mm^2 chip can provide.

Therefore, if we fix the area, we implicitly bound both memory size and
bandwidth. The notion of bandwidth hardness then translates to a lower
bound on time as a function of area, i.e. to the lower bound on the cost.
The same we already have for the memory, where memory-hardness implies a
lower bound on the amount of computations needed to compute the function
and thus to the lower bound on the time, since the parallelism is bounded
by the area.

----------------

As a side note, I find strange that you still consider Momentum. Memoryless
collision search is so well known and explored, that this scheme is barely
better than plain SHA-256.

Best regards,
Dmitry

On Sun, Jul 12, 2015 at 12:02 AM, Bill Cox &lt;waywardgeek&#64;...il.com&gt; wrote:

&gt; Is this a good term to use to describe password hashing and PoW algorithms
&gt; with ASIC defense based on the expense of I/O ports with high data
&gt; bandwidth?
&gt;
&gt; Here are the differences I see between bandwidth-hard algorithms vs
&gt; memory-hard algorithms:
&gt;
&gt; - Memory hard algorithms compute a serial chain of data values that must
&gt; be computed sequentially
&gt; - Bandwidth hard algorithms allow an attacker to compute hash values in
&gt; parallel
&gt; - Memory hard algorithms require significant memory per parallel worker
&gt; - Bandwidth hard algorithms allow the data to be shared between parallel
&gt; workers, but it must be transmitted between them
&gt; - Memory-hard algorithms defend against ASIC attacks through the cost of
&gt; memory, the cost of bandwidth, or both
&gt; - Bandwidth hardened algorithms limit ASIC attacks through communication
&gt; bandwidth
&gt; - Memory-hard algorithms tend to have long verification times for PoW
&gt; - Bandwidth-hard algorithms tend to have short verification times for PoW
&gt;
&gt; In most of my proposed ASIC attacks against memory-hard algorithms, memory
&gt; bandwidth limited the overall speed of the attack.  The cost of the
&gt; external memory was rarely significant.  For example, if bandwidth is not a
&gt; concern, I can buy a 1TiB hard drive for under $100.  If I need 350 GiB/s,
&gt; it will cost several hundred dollars, regardless of the amount of memory
&gt; I'm buying.  It seems to me that bandwidth hardening defends more reliably
&gt; than memory cost.  While bandwidth hardened algorithms have disadvantages
&gt; (like those listed above), the fast verification makes them suitable in
&gt; some cases for PoW.
&gt;
&gt; I know of three bandwidth-hardened algorithms: Momentum, Cuckoo Cycle, and
&gt; what I was calling "CPU Hash", which ideally is something like Yescrypt
&gt; running with a very small amount of RAM, and a reasonable amount of ROM, or
&gt; an EARWORM with expanded state size.
&gt;
&gt; SFAICT, all three algorithms provide reasonable ASIC defense.  The benefit
&gt; for each is that verification is very fast.  There is also Argon2's
&gt; proposed Merkel hash tree built on top of the memory filled by Argon2.
&gt; Like Cuckoo Cycle, this allows for log(n) speed verification.  However, the
&gt; Merkel hash tree building dominates the runtime, reducing the benefit of
&gt; running Argon2 as a pre-process rather than just filling memory in parallel
&gt; with hash data.  An advantage of a CPU-hash-like algorithm is simplicity
&gt; and I believe a simple proof of security, but then you have to have the ROM
&gt; available everywhere to do verification.
&gt;
&gt; An important key for fast-verification PoW bandwidth-hardened algorithms
&gt; seems to be high speed computation that fills available memory bandwidth,
&gt; with no significant short-cut available to an attacker.  These slower
&gt; memory-filling implementations I've seen so far give an ASIC attacker too
&gt; much gain.
&gt;
&gt; Bandwidth hardening only works if you use a lot of bandwidth.
&gt;
&gt; Bill
&gt;



-- 
Best regards,
Dmitry Khovratovich

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
