<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] Specification of a modular crypt format</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="6">[&lt;prev]</a> <a href="8">[next&gt;]</a> <a href="6">[&lt;thread-prev]</a> <a href="9">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CAGiyFdc7cj34OcK4FmjUGF0PhZO5d7fi40Yo5bKrWMYyhTW2Tg&#64;mail.gmail.com&gt;
Date: Wed, 16 Sep 2015 19:34:27 +0000
From: Jean-Philippe Aumasson &lt;jeanphilippe.aumasson&#64;...il.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] Specification of a modular crypt format

A deterministic encoding of values indeed reduces the risk of parser bugs.
It's also easier for us to specify. Otherwise, we'd have to decide what
should (not) be tolerated, for example 00001, 1.000, 01.0, etc.

Concerning the parameters' order, we know how to design reliable parsers
for such simple inputs. I don't see how it would hurt.

On Wed, Sep 16, 2015 at 8:36 PM Thomas Pornin &lt;pornin&#64;...et.org&gt; wrote:

&gt; On Wed, Sep 16, 2015 at 10:03:22AM +0000, Jean-Philippe Aumasson wrote:
&gt; &gt; Krisztián asks two important questions, regarding the encoding
&gt; flexibility
&gt; &gt; and parameters ordering. I don't know what's the usual practice to deal
&gt; &gt; with those. Can't parameters be in arbitrary order?
&gt;
&gt; The way my draft specifies things, there is a unique encoding for a
&gt; given set of parameters and salt value. This is what I call
&gt; "deterministic". Having a deterministic encoding makes parsing a bit
&gt; easier, and, maybe more importantly, makes tests easier as well: you
&gt; can simply verify that you obtain the expected test vector.
&gt;
&gt; This is not an absolute requirement. Right now, existing formats for,
&gt; say, SHA-256 crypt, are not deterministic, since one can omit or include
&gt; the '$rounds=5000' parameter. This does not apparently prevent password
&gt; verification. In the crypt() API, the returned string is the
&gt; concatenation of the salt string, _as it was received_, and the hash
&gt; output, which rather cleanly tolerates all variants in parameter
&gt; encoding.
&gt;
&gt;
&gt; IF we want deterministic encoding, then a numerical parameter of value
&gt; '1' can only be encoded as '1', not '01' or '001' (or, alternatively,
&gt; can be encoded only as '001', not '01' or '1'; or any other convention
&gt; as long as there is no choice). Otherwise, determinism is not achieved.
&gt; This should answer Krisztián's first question: yes, it is intentional
&gt; that '001' be rejected.
&gt;
&gt;
&gt; Krisztián's second question is about lexicographic order. Still under
&gt; the idea that we want a deterministic encoding, then the parameters
&gt; cannot appear in arbitrary order; a fixed order must be specified.
&gt; However, that order can be specific to each function. In the
&gt; specification, I currently defined that lexicographic ordering of
&gt; parameter names must be used, but any convention is as good as any
&gt; other. If, for aesthetic reasons, it is considered that the normal
&gt; parameter ordering for Argon2 is 'm,t,p' and not 'm,p,t', then it is
&gt; certainly possible to define the encoding format for Argon2 to use
&gt; 'm,t,p'.
&gt;
&gt; Defining a systematic rule (lexicographic order) for all hash functions
&gt; potentially helps in writing a generic decoder: each function just has
&gt; to invoke the decoder with a list of parameters to expect; if the rule
&gt; is per function, then the decoder must be invoked with an _ordered_ list
&gt; of parameters. This is not substantially harder, so I'd say that letting
&gt; each function define the ordering of parameters is possible.
&gt;
&gt;
&gt; Of course, if we decide that determinism is not needed or not desirable,
&gt; then both of these questions become irrelevant. However, accepting
&gt; parameters in arbitrary order makes the parser more complex, and we need
&gt; a lot many more test vectors to account for the greater number of
&gt; possible combinations.
&gt;
&gt;
&gt;         --Thomas Pornin
&gt;

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
