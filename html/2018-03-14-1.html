<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] How to: A super-efficient cryptographic accumulator?</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="../../../2018/03/13/10">[&lt;prev]</a> <a href="../../../2018/03/15/1">[next&gt;]</a> <a href="../../../2018/03/13/9">[&lt;thread-prev]</a> <a href="../../../2018/03/15/1">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CADPMZDBJgms0hMmGcM3hXL-Oj2cNkVhYYQhBOuLbEAx6DFmuRw&#64;mail.gmail.com&gt;
Date: Wed, 14 Mar 2018 06:24:33 -0500
From: denis bider &lt;denisbider.ietf&#64;...il.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] How to: A super-efficient cryptographic accumulator?

Ken: Thank you so much for educating me! I knew of the existence of Bloom
filters, but since I had never previously looked into them, I did not know
this is what they do. :)

That's very useful! It shows that an efficient filter can be constructed
and not all of the original entropy needs to be stored.

My question, then, transforms into the following:

Is anyone aware of any work on an algorithm / data structure with a
different memory-time tradeoff than the Bloom filter?

What I am looking for would be exactly like a Bloom filter in concept, but
with:

- radically less memory use;

- computational cost could be increased by orders of magnitude to construct
the filter;

- but the computational cost of using it should remain reasonable.

Is anyone aware of any work involving such tradeoffs?

And if not, where would be the right place to ask this question? Would the
"passwords" list be any more likely to have this answer? :-)


On Tue, Mar 13, 2018 at 10:30 AM, Ken T Takusagawa &lt;kenta&#64;....edu&gt; wrote:

&gt; For rejecting previously revealed passwords, the hash-based
&gt; Bloom Filter data structure will do the trick.  Your hash
&gt; function does not need to be cryptographically secure.  I
&gt; feel that tuning the data structure to allow the false
&gt; positive rate to be as high as 10% would be acceptable, but
&gt; that's a subjective user experience issue.
&gt;
&gt; <a href="https://en.wikipedia.org/wiki/Bloom_filter" rel="nofollow">https://en.wikipedia.org/wiki/Bloom_filter</a>
&gt;
&gt; --ken
&gt;
&gt; On Tue, 13 Mar 2018, denis bider wrote:
&gt;
&gt; &gt; Actually... I think with the hash function construction, Iâ€™ve actually
&gt; shown one of
&gt; &gt; two things:
&gt; &gt;
&gt; &gt; (a) The recognizer function, F(x) =&gt; word32, can be as small as the size
&gt; of the
&gt; &gt; hash function and its internal state.
&gt; &gt;
&gt; &gt; (b) Alternately, F(x) =&gt; word32 cannot be implemented using a  hash
&gt; function .
&gt; &gt;
&gt; &gt; The reasoning:
&gt; &gt;
&gt; &gt; Yes, if the number of passwords is N, then X would be expected to be
&gt; 32*N bits in
&gt; &gt; size. But in order to calculate SHA256(X | Pcandidate), we do not need
&gt; X. We just
&gt; &gt; need the last internal state of SHA256, which is much smaller.
&gt; &gt;
&gt; &gt; Therefore, if we have infinite computing power to generate it, a
&gt; recognizer
&gt; &gt; function F(x) can either be implemented in a compact size that is both
&gt; fast and
&gt; &gt; small to use, OR we can never find X for a large enough number of
&gt; passwords because
&gt; &gt; the internal state of a hash function is too small.
&gt; &gt;
&gt; &gt;
&gt; &gt; On Tue, Mar 13, 2018 at 4:30 AM, denis bider &lt;denisbider.ietf&#64;...il.com&gt;
&gt; wrote:
&gt; &gt;       Yeah, but... I'm still not so sure. :) People said we couldn't
&gt; have a
&gt; &gt;       digital currency either! The coins would be GIGABYTES in length! :D
&gt; &gt; This is not fractal compression because we do not intend to decompress.
&gt; We
&gt; &gt; are definitely throwing away data. What we want is a compressed oracle,
&gt; &gt; however.
&gt; &gt; The size of X I estimated if using a hash function (8 bytes?!) was
&gt; clearly
&gt; &gt; ridiculous. What I proposed was to generate X by brute-forcing it as a
&gt; &gt; counter input to a pseudo-random function that generates a string 32*N
&gt; bits
&gt; &gt; in size. If N is the number of passwords we are encoding, then to encode
&gt; 1
&gt; &gt; billion passwords, the random string needs to have 32 billion bits - and
&gt; they
&gt; &gt; all must be zero. Clearly, an X that we arrive at this way must be about
&gt; 32
&gt; &gt; billion bits in size. So, uh... 4 gigabytes.
&gt; &gt;
&gt; &gt; But what if... say... instead of a hash function - mod N arithmetic?
&gt; &gt;
&gt; &gt; Suppose we represent the passwords we want to store using primes P1, P2,
&gt; ...
&gt; &gt; Pn. We generate:
&gt; &gt;
&gt; &gt; X = P1 * P2 * ... * Pn mod N
&gt; &gt;
&gt; &gt; Of course, when we do "mod N", we are losing information. But how fast?
&gt; &gt;
&gt; &gt; Are you sure that arguments against fractal compression also apply to
&gt; highly
&gt; &gt; lossy compression like this? ZIP won't compress a PNG, but JPG will ;)
&gt; &gt;
&gt; &gt;
&gt; &gt; On Tue, Mar 13, 2018 at 3:56 AM, Poul-Henning Kamp &lt;phk&#64;....freebsd.dk&gt;
&gt; &gt; wrote:
&gt; &gt;       --------
&gt; &gt;       In message
&gt; &gt;       &lt;CADPMZDBq_CsD2ztxBX4J0FZLyf8Stm+Bz=AOPs6
&gt; Adq7frGmi1g&#64;...l.gmail.com&gt;,
&gt; &gt;       denis bider writ
&gt; &gt;       es:
&gt; &gt;
&gt; &gt;       &gt;For example, the best measure
&gt; &gt;       &gt;for password safety is probably to prevent users from using any
&gt; &gt;       of billions
&gt; &gt;       &gt;of known revealed passwords, but the compressed database is 5 GB
&gt; &gt;       in size:
&gt; &gt;       &gt;[...]
&gt; &gt;       &gt;Now. I sort of have this intuition that it=E2=80=99s possible to
&gt; &gt;       compress this crap
&gt; &gt;       &gt;into 20 bytes.
&gt; &gt;
&gt; &gt;       This is basically the old "fractal compression" idea all over
&gt; &gt;       again.
&gt; &gt;
&gt; &gt;       It always goes more or less like this:
&gt; &gt;
&gt; &gt;       1. Look at the digits of PI or E, they look awfully random and
&gt; &gt;       are
&gt; &gt;          very hard to compress.
&gt; &gt;
&gt; &gt;       2. Yet, we have this incredibly simple formula for generating
&gt; &gt;       them
&gt; &gt;          (insert favourite PI or E expression here).
&gt; &gt;
&gt; &gt;       3. What an amazing compression ratio!
&gt; &gt;
&gt; &gt;       4. There must be some function which similarly emits the MPG
&gt; &gt;       stream
&gt; &gt;          of Lord Of The Rings
&gt; &gt;
&gt; &gt;       5. Profit!
&gt; &gt;
&gt; &gt;       This thinking suffers both from logical fallacies and factual
&gt; &gt;       misunderstandings.
&gt; &gt;
&gt; &gt;       Ad 1: While it is generally a good indicator of entropy that you
&gt; &gt;       cannot compress some data, it is not a proof that the data is
&gt; &gt;       random,
&gt; &gt;       you may simply be using the wrong compression algorithm.
&gt; &gt;
&gt; &gt;       Ad 2: Deterministically generated data, no matter what its
&gt; &gt;       entropy
&gt; &gt;       might be, is never random, even when you do not know the formula
&gt; &gt;       which generated the data.
&gt; &gt;
&gt; &gt;       Ad 3: The reason the compression ratio is so amazing is that PI
&gt; &gt;       or E has infinite length.  Normally we use only about 8-16 digits
&gt; &gt;       of either and it's way more compact than your formula to just
&gt; &gt;       write down those digits.  (Footnote: 355/113)
&gt; &gt;
&gt; &gt;       Ad 4: Yes, there is undoubtedly such a function, but there is no
&gt; &gt;       reason to think that it is significantly smaller than the
&gt; &gt;       *finite*
&gt; &gt;       length bitstream you are trying to produce with it.
&gt; &gt;
&gt; &gt;       Ad 5: No, because finding the magic LOTR function has complexity
&gt; &gt;       far exceeding the size of the known universe.
&gt; &gt;
&gt; &gt;       Poul-Henning
&gt; &gt;
&gt; &gt;       --
&gt; &gt;       Poul-Henning Kamp       | UNIX since Zilog Zeus 3.20
&gt; &gt;       phk&#64;...eBSD.ORG         | TCP/IP since RFC 956
&gt; &gt;       FreeBSD committer       | BSD since 4.3-tahoe
&gt; &gt;       Never attribute to malice what can adequately be explained by
&gt; &gt;       incompetence.
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt;

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
