<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] POMELO</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="1">[&lt;prev]</a> <a href="3">[next&gt;]</a> <a href="1">[&lt;thread-prev]</a> <a href="3">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CAELGc4VWiwk3v0FTG_uQMakPreqEbk_c9d+TLyhdQ7iNcLsN6A&#64;mail.gmail.com&gt;
Date: Fri, 17 Oct 2014 19:03:28 +0800
From: Hongjun Wu &lt;wuhongjun&#64;...il.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] POMELO

Hi Alexander,

Thank you for the analysis and comments!

1)  In your mail, "POMELO claims to be resistant to SIMD attacks. First, I
think we need to clarify: this may only apply if the hardware lacks
efficient gather"

      Be more accurate, POMELO is resistant to SIMD attacks if the hardware
lacks efficient gather and scatter.

      Fortunately (or unfortunately), currently there is no efficient
gather/scatter for random data accesses (according to what I know. Maybe I
am wrong here).   On the GPUs with dozens of parallel data processor, the
gather/scatter for random data access has very long latency.  Even on the
latest Haswell CPU, it seems that the gather/scatter is implemented in
sequential rather than in parallel (taking around 10 cycles for gather the
data in L2 cache).   It is reasonable since parallel gather/scatter for
random data access requires much more extra circuits for accessing memory.


2)  In your email, "I think POMELO partially fails at anti-SIMD, despite of
claims in its specification document.  It defeats SIMD for defense (if we
don't consider hashing multiple passwords within one instance, which is
cumbersome and is a risk), but not as much for attack. "

     You are right here.  This partial failure affects the security.  But I
think that the effect on security is also partial.  The random data
read/write in H remains the bottleneck, and it cannot be easily bypassed in
SIMD, especially on GPU.

3)  I think that your tradeoff (one table lookup in every step) is
interesting.  That is my old design before optimization.  As you have
noticed, this tradeoff has some advantage, also some disadvantage.

     The rationale for the current POMELO version (one table lookup in 4
steps) is to achieve certain balance between table lookup and the
computation of F when the data is not in L3 cache (for the current desktop
CPUs).

      (The best optimization is to set different parameters for different
table sizes.  But the design would become too complicated, and inconvenient
to the users.)

Best Regards,
Hongjun


On Fri, Oct 17, 2014 at 3:17 PM, Solar Designer &lt;solar&#64;...nwall.com&gt; wrote:

&gt; Hi,
&gt;
&gt; I first brought this up as part of a broader discussion of PHC
&gt; candidates on the panel list earlier this month, and I think it's my
&gt; duty to post it to the public discussions list.  So here goes.
&gt; (I am reusing pieces from two of my postings to the panel list, and
&gt; adding some more content/clarifications here.)
&gt;
&gt; POMELO claims to be resistant to SIMD attacks.  First, I think we need
&gt; to clarify: this may only apply if the hardware lacks efficient gather
&gt; loads - a detail which may be obvious, but is somehow missing from the
&gt; author's analysis.  A lot of current and planned general-purpose chips
&gt; (AVX2 and AVX-512 capable CPUs, Xeon Phi, many GPUs) do have gather
&gt; loads (of varying efficiency), so I think this must not be omitted.
&gt; In the below paragraph, I assume that hardware does lack efficient
&gt; gather loads:
&gt;
&gt; I think POMELO partially fails at anti-SIMD, despite of claims in its
&gt; specification document.  It defeats SIMD for defense (if we don't
&gt; consider hashing multiple passwords within one instance, which is
&gt; cumbersome and is a risk), but not as much for attack.  In fact, I think
&gt; there's a tradeoff here as it relates to possible POMELO tweaks (if
&gt; limited to the currently hard-coded parameters): it can defeat SIMD more
&gt; fully, but become even less suitable (slower) for large memory hashing.
&gt;
&gt; Samuel Neves confirmed the understanding that "POMELO does seem to allow
&gt; some vectorization" (_not_ relying on gather loads), and asked for more
&gt; detail on the tweak I had in mind.  Here it is:
&gt;
&gt; I meant simply making those data-dependent accesses in H more frequent,
&gt; by removing the "i mod 4 == 3" condition or making this a tunable
&gt; parameter ("i mod freq == (freq - 1)" or "i mod freq == 0").  Maybe G
&gt; should have the same tweak applied, or maybe not (or maybe it should
&gt; have its access frequency tunable separately).
&gt;
&gt; Comparison of POMELO tweaked as above against bcrypt and other schemes,
&gt; not limited to the SIMD aspect (will also apply for MIMD, as long as
&gt; global memory is accessed and behaves similar to how it does on current
&gt; CPUs and GPUs):
&gt;
&gt; Since F takes roughly as much time as a Blowfish round does (but F lacks
&gt; data-dependent accesses), doing one data-dependent access per H
&gt; invocation (rather than one per four H invocations, as it is done now)
&gt; means that step 6 will perform these accesses "only" ~4 times less
&gt; frequently than bcrypt does (as opposed to ~16 times less frequently, as
&gt; is the case now), but at the same amount of parallelism that bcrypt has
&gt; (since the four Blowfish S-box lookups can be performed in parallel).
&gt; As a result, step 6 will become about as local memory attack resistant
&gt; as bcrypt is, but still ~4x less resistant (than bcrypt) to global
&gt; memory attacks (as long as the memory usage per instance is low enough
&gt; that we don't bump into total global memory size).  Since a half of the
&gt; total running time will be spent in step 4, overall POMELO with this
&gt; tweak and at bcrypt-like defensive memory usage might be ~2x weaker than
&gt; bcrypt at local memory attacks and ~8x at global memory attacks.  Of
&gt; course, it is meant to be used at higher m_cost - in fact, m_cost = 0
&gt; corresponds to 8 KiB, which is twice the bcrypt's size.  8 KiB should
&gt; actually work fine on typical defenders' systems, but once we exceed L1
&gt; cache size, POMELO with this tweak should see performance impact similar
&gt; to what we see with Pufferfish - well, maybe up to ~4x lower impact,
&gt; though, because the data-dependent lookups are ~4x less frequent.  It
&gt; will take some benchmarking to see at what m_cost settings such tweaked
&gt; POMELO is fast enough compared to other PHC candidates.  Not tweaking G
&gt; or otherwise making its access frequency much lower than H's may help
&gt; here (making step 4 take considerably less time than step 6 does).
&gt;
&gt; One aspect I have not considered in the analysis above is that POMELO's
&gt; data-dependent accesses in H are read-writes, as opposed to bcrypt's
&gt; pure reads.  This may make POMELO up to 2x more resistant to some of the
&gt; attacks above (where it'd mean twice more accesses over the memory bus),
&gt; but it may also mean that it'd run somewhat slower defensively than it
&gt; would with pure reads.  Yet I think these read-writes are a good idea
&gt; at least when POMELO is used at low m_cost (corresponding to L1 cache).
&gt;
&gt; Overall, I like POMELO's simplicity and it trying to work well over a
&gt; wide range of possible m_cost settings, yet I think this combination (of
&gt; simplicity and wide range) makes it sub-optimal at most settings.
&gt;
&gt; Alexander
&gt;

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
