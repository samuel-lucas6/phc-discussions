<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: Re: Re: Re: Re: Re: Second factor (was A review per day - Schvrch)</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="3">[&lt;prev]</a> <a href="../../../2014/09/11/1">[next&gt;]</a> <a href="2">[&lt;thread-prev]</a> <a href="../../../2014/09/11/5">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;luqdfq$f19$1&#64;ger.gmane.org&gt;
Date: Wed, 10 Sep 2014 13:48:55 -0700
From: Alex Elsayed &lt;eternaleye&#64;...il.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: Re: Re: Re: Re: Re: Second factor (was A review per day - Schvrch)

Andy Lutomirski wrote:

&gt; On Wed, Sep 3, 2014 at 4:15 PM, Alex Elsayed
&gt; &lt;eternaleye&#64;...il.com&gt; wrote:
&gt;&gt; Andy Lutomirski wrote:
&gt;&gt;
&gt;&gt;&gt; On Wed, Sep 3, 2014 at 3:45 PM, Alex Elsayed
&gt;&gt;&gt; &lt;eternaleye&#64;...il.com&gt; wrote:
&gt;&gt;&gt;&gt; Andy Lutomirski wrote:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; On Wed, Sep 3, 2014 at 3:29 PM, Alex Elsayed
&gt;&gt;&gt;&gt;&gt; &lt;eternaleye&#64;...il.com&gt; wrote:
&gt;&gt;&gt;&gt;&gt;&gt; Besides, why store _anything_ on the user's computer? The user types
&gt;&gt;&gt;&gt;&gt;&gt; in N, and then P, and neither has any related data stored anywhere on
&gt;&gt;&gt;&gt;&gt;&gt; the computer; the less you process P the less time it spends resident
&gt;&gt;&gt;&gt;&gt;&gt; in memory as well. Treat it like a hot potato and hand it straight to
&gt;&gt;&gt;&gt;&gt;&gt; the token.
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Because I want to trust my token as little as possible.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; My point is it doesn't actually trust your token any less.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Handing your token F(P) instead of P doesn't matter, because F(P) is
&gt;&gt;&gt;&gt; still sufficient for a malicious token to never ask again if it stores
&gt;&gt;&gt;&gt; it - and a malicious token disclosing P rather than F(P) only matters
&gt;&gt;&gt;&gt; if your password hygiene is really terrible (reuse, etc).
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Besides, the token _does_ rely on you relaying the second exchange for
&gt;&gt;&gt;&gt; it - if it tries to do an exchange when you didn't _initiate_ an
&gt;&gt;&gt;&gt; exchange, that's a 'KILL IT WITH FIRE' indicator; that leaves only that
&gt;&gt;&gt;&gt; it surreptitiously stores what you give it and waits for someone to
&gt;&gt;&gt;&gt; steal it from you.
&gt;&gt;&gt;
&gt;&gt;&gt; Let me try to say it more precisely.  I want a fourth security
&gt;&gt;&gt; requirement: even if the token is actively malicious (e.g. records
&gt;&gt;&gt; things it shouldn't, sends maliciously incorrect output, and leaks
&gt;&gt;&gt; things to &lt;insert government agency here&gt;), then the protocol should
&gt;&gt;&gt; still be as secure as either password-authenticated or
&gt;&gt;&gt; encrypted-key-authenticated protocols, depending on whether the user
&gt;&gt;&gt; stores a key file on his/her hard drive.
&gt;&gt;&gt;
&gt;&gt;&gt; I think that my protocol achieves this, or at least tries to.  Yours
&gt;&gt;&gt; seems to be completely insecure in this threat model.
&gt;&gt;
&gt;&gt; Mm, I see.
&gt;&gt;
&gt;&gt;&gt; Yours might be fixable for this purpose by having the user do a second
&gt;&gt;&gt; PAKE exchange with the server, protected by the output of the first
&gt;&gt;&gt; one.  This requires more round trips than my approach.
&gt;&gt;
&gt;&gt; Actually, another option is to run step 4 in _parallel_ with a PAKE
&gt;&gt; exchange directly between U and A. Since the exchanges are the same, this
&gt;&gt; results (assuming some bundling) in a doubling of message _size_ (and the
&gt;&gt; server must store two verifiers), but not of the _number_ of messages.
&gt;&gt;
&gt;&gt; At that point, though, you might as well not pass the token anything (or
&gt;&gt; pass it public data like the name of the service you're authenticating
&gt;&gt; to), again obviating the need for storing anything on disk while
&gt;&gt; satisfying the additional constraint unconditionally.
&gt; 
&gt; Hmm, interesting.  I had assumed that a secure protocol involving
&gt; password tokens needed some mechanism for authenticating the user to
&gt; the token to prevent the token from being useful if stolen.  But maybe
&gt; this is entirely unnecessary.

At least with SRP, I think it is unnecessary - the only output of the 
protocol (on both sides) is a key, which if the protocol failed is different 
on each end. If the _total_ derived key is made by XOR of the derived key 
from each parallel execution, and the individual derived keys are never used 
for anything, then one can only discern that the _total_ authentication 
succeeded/failed, preserving the security property.

&gt; On the other hand, it should also be impossible for a server and a
&gt; stolen user's computer to do an offline dictionary attack without
&gt; access to the token.  I think that two parallel augmented PAKE runs
&gt; doesn't have this property.  This might be fixable by storing the
&gt; client computer's key share in some form that can only be decrypted
&gt; with access to the token (e.g. take the secret PAKE key, encrypt it
&gt; against the token's secret, and encrypt *that* against the password).

Mm, with the parallel PAKE we've latched P as a necessary part of the 
protocol, so _here_ your original idea of passing H(P) to the token, which 
it uses to encrypt its (internal) value, would not weaken the scheme in the 
case of a malicious token.

Given token T holding secret X, user U holding password P, and server S:

U -&gt; T: H(P)
T -&gt; U: Y = E(k=X, H(P))
T -&gt; S: R_t = PAKE(X)
U -&gt; S: R_u = PAKE(Y)
T -&gt; U: R_t
U: K = R_t ^ R_u

With that, both verifiers on the server depend on the (strong random) X, 
preventing dictionary attacks by a malicious server unless it has the token.

And unless it's a malicious token, even a malicious server that has it will 
still need to query the token once per guess (in order to get the differing 
values of Y, which is why I didn't simply have it return H(X))

&gt; Hmm.  Maybe I should try to write this stuff down and post it to IACR.
&gt; 
&gt;&gt;
&gt;&gt; Sadly, this loses the property from the original scheme that the server
&gt;&gt; doesn't need to even know that a token is in use - a PAKE exchange
&gt;&gt; between U and A appears the same to A as the token protocol.
&gt;&gt;
&gt;&gt; It would also require care on the part of A to avoid timing leaks - it'd
&gt;&gt; need to check both verifiers even if one failed.
&gt;&gt;
&gt; 
&gt; It looks like the catid tabby PAKE might be compatible with a secret
&gt; sharing approach like in my earlier email.  It has no security proof,
&gt; though.
&gt; 
&gt; --Andy


</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
