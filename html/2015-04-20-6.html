<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] "Attack on the iterative compression function"</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="5">[&lt;prev]</a> <a href="../../../2015/04/21/1">[next&gt;]</a> <a href="5">[&lt;thread-prev]</a> <a href="../../../2015/04/23/4">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;20150420221353.GA15182&#64;openwall.com&gt;
Date: Tue, 21 Apr 2015 01:13:53 +0300
From: Solar Designer &lt;solar&#64;...nwall.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] "Attack on the iterative compression function"

Hi Dmitry,

On Mon, Apr 20, 2015 at 11:36:09PM +0200, Dmitry Khovratovich wrote:
&gt; I did add extra 1/16 of memory to each tradeoff attack (line 613 of
&gt; the code), so you should not add it again.

I saw this line, but I thought that when the program reports e.g.
"fraction 6", it does not take that calculation into consideration, or
does it?  To me, the "6" appears to come from q from the "for (unsigned
q = 2; q &lt;= 80; q++)" loop.  Does the tradeoff attack somehow ensure
this 1/q ratio is met exactly, including the 1/16 extra into the
accounted for memory?

&gt; The program outputs different C(q) because it runs multiple tests
&gt; where addresses are determined randomly. For each iteration the memory
&gt; saving and the penalty is different, and I just average them over 100
&gt; tests.

Yes, I've since figured that out.  Thanks.

&gt; The parameter WIDTH_SIZE/3q determines the number of the most
&gt; expensive blocks. They are so expensive that we store any block that
&gt; refer to them, that's the idea of the ranking method.

Is the "3" in this parameter tunable?  If so, is "3" optimal?

&gt; I should add that C(q) is actually overestimated in the program.
&gt; First, it does not take into account that the total number of blocks
&gt; is limited (2^20 for 1 GB, for example). Secondly, it counts every
&gt; block as many times as it appears in different branches of the
&gt; recomputation tree. A more clever tradeoff method would not recompute
&gt; the same block too many times.

OK.

&gt; Regarding your comment on the average memory use, I note that the
&gt; program does not exploit all the memory immediately. For every block
&gt; it decides whether to store it or not, and does not delete the blocks.

Of course, no program nor even ASIC can possibly put all memory to use
instantly (for one hash computation).  My point was that without TMTO
the memory usage grows relatively slower (relative to the total running
time) than with TMTO, because with TMTO each iteration of the original
loop takes progressively longer as the recomputation depth grows.  For
example, the first few iterations don't become slower at all (since they
don't depend on any non-stored blocks yet), while the last few may be
many times slower (as the recomputation depth is near its maximum).
During those first few iterations, the memory usage is negligible.
During those last few iterations, the memory usage is nearly the
highest.  It's due to the change in shape of this curve (memory usage
vs. real time) that I expect a higher average/peak memory usage ratio
over (also normalized) time for the TMTO case.  Or in other words, the
area below the curve normalized for peak memory usage and total running
time, or the integral of average/peak ratio over time divided by the
TMTO-increased running time, will also be higher.  That's a multiplier
you could need to apply to your reported memory ratios (of course, along
with due explanation).

Thanks,

Alexander
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
