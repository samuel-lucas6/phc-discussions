<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] "Attack on the iterative compression function"</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="8">[&lt;prev]</a> <a href="10">[next&gt;]</a> <a href="7">[&lt;thread-prev]</a> <a href="10">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CAOLP8p52e6ihP98HG2ATSJg+9JAc12Z47cVfTsyZrws5iYRPaQ&#64;mail.gmail.com&gt;
Date: Sat, 18 Apr 2015 22:52:06 -0700
From: Bill Cox &lt;waywardgeek&#64;...il.com&gt;
To: "discussions&#64;...sword-hashing.net" &lt;discussions&#64;...sword-hashing.net&gt;
Subject: Re: [PHC] "Attack on the iterative compression function"

On Sat, Apr 18, 2015 at 1:42 PM, Solar Designer &lt;solar&#64;...nwall.com&gt; wrote:

&gt; On Fri, Apr 17, 2015 at 10:05:47AM -0700, Bill Cox wrote:
&gt; &gt; Here's the outrageous claim they make against Yescrypt:
&gt; &gt;
&gt; &gt;   for 1/4 memory, Yescrypt has a 1/2 "Time-memory product"
&gt; &gt;
&gt; &gt; In their previous table, they say that at a 1/4 memory attack, the
&gt; attacker
&gt; &gt; must do 1135 times more computation.  The time*memory defense as used by
&gt; &gt; the whole world other than the Argon team is therefore 283.75.  This
&gt; paper
&gt; &gt; is off by a factor of 567.5!
&gt; &gt;
&gt; &gt; I do not consider this a weakness of Yescrypt.  I wish the Argon team
&gt; would
&gt; &gt; start using proper terminology.
&gt;
&gt; As I'm sure you realize, it's the difference between computation time
&gt; and best possible real time (assuming unlimited parallelism and no
&gt; latency overhead on putting that parallelism to use).  I think both
&gt; metrics make sense and are useful for us to consider.  I appreciate that
&gt; analyses by the Argon team list C(q) and D(q) separately.
&gt;

I agree.  The C(q) and D(q) tables are helpful.  It's their conclusion that
an attacker can spend 1/2 as much per guess as a defender based on a TMTO
attack that is simply wrong, and I believe purposely misleading.  We've
equated memory*time to dollars all along, and they redifined it entirely
differently, probably specifically to mislead readers.


&gt; Dmitry's "Tradeoff for Yescrypt" short paper does acknowledge that for
&gt; their factor of 6 memory reduction "in practice the computational
&gt; overhead will be probably too large".  Per the first table, it'll be
&gt; 2^19 for factor of 5, and it is not even listed for factor of 6.


How nice of them to agree that a number of parallel CPUs to large to even
calculate will not be free, zero power, and zero latency :-)  Now, could we
get them to consider the impact at the 1/4 level properly?


&gt; Thus,
&gt; I am more concerned about the attack at lower TMTO ratios, 1/2 to 1/4
&gt; inclusive, where the required number of parallel cores isn't necessarily
&gt; prohibitive per se.


If their C(q) number is right, and the attacker has to have over 1100X more
computation, then I would not worry so much about the 1/4 memory case.
It's more likely that an attacker could find some benefit in the 3/4 to 1/2
memory range, but probably not enough to bother.

The latency overhead on putting those cores to use
&gt; (including extra latency coming from the increased memory bandwidth
&gt; usage on needing to fetch, if I am correct, roughly twice more data at
&gt; the 1/4 ratio) may be more of a problem, and may defeat the attack in
&gt; some cases.
&gt;

The routing delays will also help defeat this attack, though I already
consider it quite dead at the 1/4 TMTO level simply due to the huge power
increase.  1100 cores might literally melt the chip if run at full speed.


&gt; BTW, I think it's 1/4+3/64 memory (the paper mentions this detail, just
&gt; not in the table)


in a pattern that's familiar...


&gt; , but that's close: 25% vs. 29.7%.  Another detail is
&gt; how the average (rather than peak) memory usage is reduced with TMTO.
&gt; The recomputation depth grows the longer the algorithm runs, so the
&gt; average (across the running time) is skewed towards a higher portion of
&gt; the TMTO'd memory size.  For yescrypt at t=0 without TMTO, the memory
&gt; fills up at 3/4 of the running time, and the average usage is 5/8.
&gt;

This is a reasonable balance.

If the 1/4+3/64 fills up e.g. at 1/2 of the running time (and does so
&gt; linearly, even though this is certainly not the case), the average is
&gt; 3/4 of that, which is higher than the non-TMTO 5/8.  So we'd get
&gt; (1/4+3/64)*3/4 / (5/8) = 35.6% average memory usage under TMTO, which
&gt; isn't as bad as the 25% where we started.  That's just an example.
&gt; We might want to figure out the actual number.
&gt;

I would not worry about attackers who are willing to pay over a 1000X
computation penalty to do a 1/4 memory attack.  That's just nuts.  I'd
focus more on the minimal TMTO attacks, but from their data, Yescrypt looks
pretty solid there, too.


&gt; I do consider yescrypt's susceptibility to beneficial (at least under a
&gt; simplified theoretical model) tradeoff attacks on its BlockMix a
&gt; drawback of the current yescrypt design.


The theoretical model is very highly unrealistic.  It's not a case worth
worrying about, IMO.

I am thinking of addressing
&gt; this through documentation, recommended parameter values (for r and t),
&gt; and possibly a tweak (if permitted in PHC, or beyond PHC if yescrypt
&gt; isn't selected as a winner).  For example, it can be said (in revised
&gt; documentation) that t=0 is recommended when only computation*memory
&gt; tradeoffs need to be defeated,


I don't understand.  Are you saying there is a beneficial
computation*memory attack against Yescrypt?  I thought the high C(q)
numbers they reported help disprove that.  Computation increases faster
than memory is reduced at all points in their table.  Since power is
roughly 1/2 of an attacker's budget, it is unlikely that there is any
trade-off that benefits an attacker, who mostly cares about cost per guess.

and t=1 or higher when also
&gt; latency*memory tradeoffs need to be defeated under assumption that the
&gt; attacker has abundant parallel computing resources (but limited memory).
&gt;

I do not think this would be good advice.  In virtually all cases, uses are
best protected with minimum t_cost.  There may be an attacker out there who
is forced to do a 1/2 memory TMTO to fit into his RAM, but the increase in
computation will hurt him in terms of cost per guess.  The only use case I
see for t_cost &gt; 0 is when the defender has a fixed amount of memory and
does not mind waiting a very long time for hashing to complete.  It's
talked about a lot on this list, but I've never seen this used in the wild.

Personally, I wish t_cost could be dropped from the API for memory-hard
hashing.  Users will not correctly guess that their protection is maximized
by minimizing t_cost.


&gt; As to a possible tweak, I'd appreciate attacks on scrypt's shuffling and
&gt; on the reverse order sub-blocks (as I suggested in another message).
&gt; While it can be said that these are attacked by storing additional
&gt; intermediate sub-blocks, that general statement isn't actionable for me
&gt; to choose the more effective mitigation, nor to document exactly how
&gt; effective or not it is.
&gt;

Some more analysis would be good.  This is the kind of thing the Argon guys
seem pretty good at.


&gt; Another option is to adopt Argon2's compression function and introduce
&gt; tunable parallelism (optional data dependencies) and pwxform rounds into
&gt; it, although I doubt I'd reach bcrypt-like frequency of S-box lookups
&gt; there (as I'd need to keep the BLAKE2b rounds as well, for full
&gt; diffusion, or otherwise this would be pointless).  If so, I'd also
&gt; replace the uses of Salsa20 with BLAKE2b, but even then the overall
&gt; complexity of full implementation would increase (as Salsa20 would also
&gt; be needed when scrypt compatibility is compiled in).  So it's not an
&gt; option I like.  Something like this may be more appropriate for a
&gt; revision of Argon2 than for a revision of yescrypt.
&gt;
&gt; Alexander
&gt;

I like Yescrypt as it stands.  Salso20 is fine for the mixing between
blocks.  It's probably overkill.  Scrypt compatibility is another thing
entirely... I'm not sure it's worth the additional complexity to retain it,
but it is a nice feature.

In a stripped down version, I'd like to drop Scrypt compatibility, fix
t_cost to 0, and use one thread with 1/3 as many transform rounds, which is
what I think the default should be when running on 1 thread.

Bill

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
