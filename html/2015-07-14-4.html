<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] Bandwidth hardened algorithms?</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="3">[&lt;prev]</a> <a href="5">[next&gt;]</a> <a href="1">[&lt;thread-prev]</a> <a href="5">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CAOLP8p7=8xiE7qfgxNiAvnAUWNObs4u+HsUh2D=xWiyht_C3rA&#64;mail.gmail.com&gt;
Date: Tue, 14 Jul 2015 10:02:08 -0700
From: Bill Cox &lt;waywardgeek&#64;...il.com&gt;
To: "discussions&#64;...sword-hashing.net" &lt;discussions&#64;...sword-hashing.net&gt;
Subject: Re: [PHC] Bandwidth hardened algorithms?

On Mon, Jul 13, 2015 at 9:06 PM, denis bider &lt;pwhashing&#64;...isbider.com&gt;
wrote:

&gt; &gt; So the problem addressed in this discussion is how to defend against
&gt; &gt; ASIC mining.  You have to find something that a CPU and/or a GPU can
&gt; &gt; do well that an ASIC wont do much better.  Requiring a lot of memory
&gt; &gt; and serial computation of the data you use to fill it makes the
&gt; &gt; algorithm memory-hard, but if you fill memory slowly due to slow
&gt; &gt; cryptographic hash computations, and ASIC will beat you on speed.
&gt; &gt; This seems to be where we are with current algorithms, IMO.
&gt;
&gt; And I think the solution to that is going to be WebAssembly.
&gt;
&gt; Generate a bunch of relatively random, yet still application-like, and
&gt; platform-independent code. Execute it in WebAssembly sandbox. See who runs
&gt; it faster, custom ASIC or CPU.
&gt;

I agree, especially for PoW, where we're less concerned about an attacker
trying to PWN your computer.  Executing random machine code seems like a
reckless thing to do in password authentication, but it would bother me
less in a PoW system.

While we can probably defend well against ASIC miners, just by using
something like Yescrypt or a random machine code engine, we still have the
problem that verifying the block chain is too computationally expensive.
There is an argument that having block verification that takes &gt; 1 second
is OK, because most clients would only verify new blocks they see every few
minutes.  However, I think this verification issue is what has held back
good memory-hard PoW systems so far.  Even the one based on Yescrypt we
already see is using far too little memory.

A similar problem exists for ROM based PoW with fast verification (what I
have been calling CPU Hash for lack of a better name).  A CPU Hash
algorithm based on Yescrypt would be very fast, and GPU resistant as well
as ASIC resistant.  With a large ROM, say 32 GiB or more, it is even fairly
botnet resistant, which is super cool.  However, for verification, every
client needs the whole ROM, which means they need a ton of memory.

Is there is a trade off that could make CPU Hash verification acceptable?
For example, let's say the ROM is 32 GiB, meaning efficient miners need
that much memory.  This ROM should not be actual random data, because that
would require transmitting the whole ROM to each client.  What if instead
we generate it from a memory-hard hash function in counter mode?  For
example, we could use Yescrypt to generate 128 MiB memory blocks.  A client
would only need to compute 2 of these per verification, and it would only
do this now and then.  A miner, or advanced client which wants to verify
the whole block chain would generate all 32 GiB and keep it in memory,
vastly accelerating block-chain verification.

What do you think?  Would something like this be close?

Bill

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
