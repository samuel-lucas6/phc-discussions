<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] Deliberately GPU-friendly password hashes?</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="34">[&lt;prev]</a> <a href="36">[next&gt;]</a> <a href="32">[&lt;thread-prev]</a> <a href="36">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;alpine.DEB.2.10.1404031607370.16514&#64;debian&gt;
Date: Thu, 3 Apr 2014 17:02:08 +0200 (CEST)
From: Stefan.Lucks&#64;...-weimar.de
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] Deliberately GPU-friendly password hashes?

On Thu, 3 Apr 2014, Bill Cox wrote:

[...]
&gt; Speed not mattering in a memory hard password hashing scheme seems to
&gt; me to be an attitude from academia. In the real world, time always
&gt; matters (did that login take 0.1 seconds or 10s?), [...]

Being from academia myself, I have to point out that this is definitively 
not an "attitude from academia"!. Who on earth would dispute that it 
matters if a log-in takes 0.1 or 10.0 seconds?

Most likely, the defender has certain budgets for time and memory, any you
need two tunable parameters (like "pepper" and "garlic") to make sure that
your password hash uses the budgets, without exhausting them.

&gt; Finally, I am saddened to be the only submitter to use a cryptographic
&gt; primitive like SHA256 for securely deriving an initial key, but then
&gt; filling memory with non-cryptographically pseudo-random data.  The
&gt; guys using the new AES instructions might be fast enough, but every
&gt; other memory hard entry is speed limited due to their reliance on a
&gt; strong hash function for deriving data to fill memory.

Well, this raises the workload (=time) for both the attacker and the 
defender, so this should be OK. At worst --I guess, this is your concern-- 
you cannot use the full memory budget, since you would otherwise exhaust
the time budget.

But usually, filling the memory takes a fraction of the time (one half, or 
1/4 or so) for the full password hash, so alternative ways of filling the 
memory don't give you that much of an advantage -- hardly worth the 
security assurance you loose that way, see below.

&gt; However, a lot of these entries have trivial tests for non-randomness 
&gt; that easily prove the memory is the result of their PHS, and not random.

Interesting point! So if the data are left in the memory, rather than 
deleted at the end of the password hashing, some adversary can check if a 
certain password hash function has been applied or not.

Academically, this is a cool new attack scenario! I have doubts, though, 
that this has much practical relevance in the context of PHC -- who would 
really want to hide the fact that (s)he is using a certain password hash, 
or hashing a password at all? And the executable is in memory, also.

What I (yes, I am an academic) consider a lot more relevant is what we 
called the "garbage collector attack" in the Catena submission:

     If, after executing the password hash function, the memory has been
     released, how much can the adversary, who is searching for the
     password, benefit from reading that memory?

This ought to be a concern for every memory-hard password hash.

Of course, you should whipe the memory, before you release it ... but this 
is forgotten so often, even when the memory actually holds cryptographic 
keys.

&gt; The only benefit of using a slow cryptographic primitive in this case is 
&gt; that there is little need to worry that the whole thing can be reversed, 
&gt; revealing the password or initial derived key.

Agreed! This is one benefit, though not the only one.

&gt; I suppose it also makes it simple to prove that there are no short-cuts 
&gt; an attacker can take.

Agreed! This is another benefit.

&gt; However, simply applying a strong hash function now and then should be 
&gt; enough to gain similar confidence [...]

Now, this is the point where we disagree!

When using a strong primitive everywhere, you can make a strong argument 
(mathematically: a "proof") that your password hash function is secure if 
the underlying primitive is secure. (Of course, this also depends on a 
carefully designed structure, that supports such a "proof".)

Then, if the primitive you are using has been analysed well, you inherit 
that primitive's security assurance. You are even free to switch to 
another primitive, if you would trust that primitive more.

Otherwise, in the "here and there" case, you have invented your own 
cryptographic primitive. This is a cool thing, there is nothing wrong with 
doing so!

But in spite of calling some other primitive "here and there" you don't 
inherit the security assurance from that other primitive. Your password 
hash function might turn out as weak, regardless of the strength of the 
other primitive.

Any new primitive has a low security assurance, initially. If it is 
intensively analysed, and nobody finds a flaw, then over the years, people 
gain confidence in the primitive -- i.e., it collects security assurance. 
But that takes years, at best -- why, do you think, did the AES- and the 
SHA-3 process take so long? (And note that these two where extremely 
prominent and did attract the top cryptographers -- I am not quite so 
optimistic for PHC candidates, especially with the ongoing CAESAR 
competition ...)

&gt; Anyway, I think applicability for GPU password strengthening should be
&gt; one of the criteria used by the PHS judges.

Definitively!

So long

Stefan

------  I  love  the  taste  of  Cryptanalysis  in  the morning!  ------
     &lt;<a href="http://www.uni-weimar.de/cms/medien/mediensicherheit/home.html" rel="nofollow">http://www.uni-weimar.de/cms/medien/mediensicherheit/home.html</a>&gt;
--Stefan.Lucks (at) uni-weimar.de, Bauhaus-Universit√§t Weimar, Germany--

</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
