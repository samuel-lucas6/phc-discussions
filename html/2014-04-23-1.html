<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Dumb fast file digest idea...</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="../../../2014/04/22/1">[&lt;prev]</a> <a href="2">[next&gt;]</a> <a href="2">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CAOLP8p63PjksYJBziypASr3K60LkQQOL-fdSbcXkjxVDN8R8tA&#64;mail.gmail.com&gt;
Date: Wed, 23 Apr 2014 09:11:57 -0400
From: Bill Cox &lt;waywardgeek&#64;...il.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Dumb fast file digest idea...

Sorry about going slightly off-topic for this list, but certainly there are
experts here who will see the flaws in this idea.  Basically, I'm wondering
if we can use a memory buffer to considerably speed up computation of
secure file hashes using reducing rounds, without giving up any security.

I was trying last night use the new AESENC instruction to compute file
hashes very rapidly.  There are probably more problems with AESENC, but a
major one is that a single round (one AESENC instruction) is by itself not
cryptographically secure.  It normally requires 10 rounds to produce a 128
bit encrypted result, plus a lot of mucking with round keys and such.  When
I use AESENC to encrypt a "state" using sequential 16-byte blocks of the
message as the key, I don't think the resulting hash is secure.  Being a
speed freak, I love it's speed!  I am able to compute a digest of a random
512MiB file in 68 milliseconds!  The file was already cached, of course.
 Being secure would be a plus in this situation...

To find a collision, an attacker only has to figure out how to modify two
adjacent blocks of 16 bytes of the file in such a way that it results in
the same encrypted state 2 AESENC instructions later.  While that is likely
difficult, it is nowhere near the effort of doing that if we had performed
the full AES algorithm each 16 byte block.

What if we do a simple post-process on the sequence of states generated?
 Just fill a memory buffer with the computed 16-byte state values,
incrementing by say 128*16 every time, so that we have to make 128 passes
over the memory to fill it.  This insures that state blocks which are near
each other in memory are vastly separated computationally, by very many
rounds of AESENC.  Once the block of memory is full, feed it into the
original simple AESENC loop, using sequential blocks of 16-bytes from the
buffer as the key.

This takes 2 AESENC instructions per 16 bytes of output, and probably busts
into L2 cache, but I bet it's still very fast.  As with EARWORM, running 4
parallel tracks of AESENC speed things up considerably.  I've probably
messed up a number of details, but can such an algorithm provide the same
security of other 128-bit cryptographic hashes, while running much faster?
 The same scheme could be (and maybe I'll write this) used with Blake2b,
doing 1 round of Blake2b rather than 8, filling memory as above, and doing
a 1 round hashes of the buffer when full.  The last partial buffer could be
processed in the usual way, with full rounds.  I think it would run
amazingly fast.  We'd be doing an average of 2 rounds rather than 8 per
32-byte block.  Would it be secure?

Bill

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
