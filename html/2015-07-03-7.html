<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] Password hashing as a self-overwriting Turing machine: new
 version (July 3)</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="6">[&lt;prev]</a> <a href="8">[next&gt;]</a> <a href="3">[&lt;thread-prev]</a> <a href="8">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CAOLP8p4STEEF+NmNZK_x2mkO-79R+Z360jQKveab4=-ziYQdkw&#64;mail.gmail.com&gt;
Date: Fri, 3 Jul 2015 05:49:55 -0700
From: Bill Cox &lt;waywardgeek&#64;...il.com&gt;
To: "discussions&#64;...sword-hashing.net" &lt;discussions&#64;...sword-hashing.net&gt;
Subject: Re: [PHC] Password hashing as a self-overwriting Turing machine: new
 version (July 3)

On Thu, Jul 2, 2015 at 11:10 PM, denis bider &lt;pwhashing&#64;...isbider.com&gt;
wrote:

&gt; I have addressed reported shortcomings in BusyBeaver. Most of them (if not
&gt; all?) have been pointed out by Bill Cox.
&gt;
&gt; The new latest version is here:
&gt;
&gt; <a href="http://www.denisbider.com/BusyBeaver-20150703.zip" rel="nofollow">http://www.denisbider.com/BusyBeaver-20150703.zip</a>
&gt;

Wow, that upgrade was fast!  Nice work.


&gt;
&gt; Changes:
&gt;
&gt; (1) A *parallel implementation*, ParaBeaver, is now implemented
&gt; separately in ParaBeaver.h/.cpp. It uses C++11 threading in order to run a
&gt; number of concurrent threads processing BusyBeaver instances. ParaBeaver is
&gt; useful on clients that can expect to have most cores idle, and can benefit
&gt; from parallelization to gain security at no cost to the user. ParaBeaver
&gt; works by allocating room for N number of digests, which are computed in
&gt; parallel based on N number of variations on original salt and password
&gt; inputs. When all N digests have been computed, a hash of the concatenated
&gt; digests forms the final result. In the special case when N=1, the final
&gt; result equals the result of the one BusyBeaver instance. This is a very
&gt; general parallelization construct that would work well with practically any
&gt; similar serial algorithm.
&gt;

This is close, but now you've given an attacker a free time-memory
trade-off.  He can compute each of the N hashes in parallel, or
sequentially.  To mostly defeat that, data should be copied between
instances at some point.  What I did in TwoCats was sync threads at 1/4
memory filling intervals, and allowed threads to access any data from any
thread from a prior filled interval.  IIRC, Yescrypt and Lyra2 have
something slightly simpler, but good enough.


&gt; (2) An additional parameter is now supported, swapBlockThreshold, which
&gt; provides a *hybrid mode tradeoff* between side channel resistance and
&gt; preventing an attacker from rearranging the order in which instructions are
&gt; executed so as to better fit into the attacker's cache. BusyBeaver will now
&gt; operate in side-channel-free mode the first 1/4 of the time, and then
&gt; switch to block swapping. During block swapping, the roles of SaltBlock and
&gt; PwBlock are exchanged at every jump, so that both blocks begin to control
&gt; jumps and offsets, and both blocks are read from and written to. ParaBeaver
&gt; supports swapBlockThreshold, and computes it sensibly for use in
&gt; multithreaded execution.
&gt;

Nice.  I like it.


&gt; (3) The BusyBeaver class is now templated to allow use of an *arbitrary
&gt; hash* and HMAC. SHA-512 continues to be the default and suggested hash.
&gt;

Very good.


&gt; (4) The implementation of *MulModOp64* now uses a right shift by 4 bits
&gt; between multiplication and modulo in order to use a portion of
&gt; multiplication result that preserves more entropy. The result of MulModOp64
&gt; is now used via rotBits in all instructions, to prevent the CPU from
&gt; detecting it's not used and optimizing it away.
&gt;

That should work.  It also makes your algorithm more ASIC attack
compute-time resistant since you're building chains of multiply operations.


&gt; I believe this addresses all raised concerns, while preserving the
&gt; simplicity of the algorithm. Please let me know if I have missed an
&gt; important concern!
&gt;

 Well... not _all_ my concerns.  I would prefer that BusyBeaver_BlockSize
be a parameter to the algorithm rather than a constant.  That would make it
more suitable for both server and client defense, without adding
significant complexity.

With these changes, I think your not losing any entropy, since every
operation is reversible.  That said, now you have a minor additional
problem: the computation prior to the final hash ran be run entirely
backwards.  In most of the PHC entries, this could be used in some cases to
benefit an attacker in a TMTO attack, since it gives him more ways to
recompute values that are missing from memory.  In the case of BusyBeaver,
you overwrite memory so many times, I doubt there's much reason to be
concerned about TMTO attacks.

However, like Bcrypt, BusyBeaver in it's current form uses very little
memory (it fits in L2 cache), and overwrites it many times.  This is good
for GPU defense, and this makes a nice server-side algorithm.  However, for
full-disk encryption or unwrapping user keys, I'd prefer to use _lots_ of
memory - maybe a GiB.  In this case, the memory wont be overwritten many
times like it is server-side.  Your algorithm would then become more
sensitive to TMTO attacks, as it should.  There's no point lowering
memory*time defense much due to paranoia about TMTO attacks.  Lyra2 suffers
a bit in this regard, making it a bit slower than Yescrypt and Argon2d.  A
reasonable defense is to introduce a cryptographic hash now and then into
your computations, which force an attacker to move compute forward.  For
example, you could compute hashState = SHA512(hashState || registerValue)
every 10000 or so loop iterations, and do registerValue ^=
lower64(hashState).

However, this is really a minor concern, IMO, so feel free to leave it out
;-)

Bill

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
