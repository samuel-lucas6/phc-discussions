<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] Thoughts about Argon2 PoW system</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="2">[&lt;prev]</a> <a href="4">[next&gt;]</a> <a href="2">[&lt;thread-prev]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CAOLP8p6hqNUzBm5FaSbLTJ8=qBHfPE1BPX98=cZK035sWBmfiA&#64;mail.gmail.com&gt;
Date: Mon, 13 Jul 2015 12:50:25 -0700
From: Bill Cox &lt;waywardgeek&#64;...il.com&gt;
To: "discussions&#64;...sword-hashing.net" &lt;discussions&#64;...sword-hashing.net&gt;
Subject: Re: [PHC] Thoughts about Argon2 PoW system

If the full Blake2bp were able to run fast enough to fill memory bandwidth
for a typical miner, this should work out well.  However, Blake2bp runs
slowly for small output hashes like we see when building Merkel hash
trees.  The speed-parity for Blake2b vs Blakd2bp is somewhere from 1KiB to
2KiB of input data on my desktop machine here.  We're better off sticking
with regular Blake2b in this case.

I wonder if it might make sense to optimize a memory-hard hashing function
like Argon2d to run well on GPUs.  GPUs typically have higher
bandwidth/dollar to memory, and enough compute power to keep that bandwidth
filled even with full strength cryptographic hashes.  If that could be made
to work well, it might have excellent ASIC attack resistance, and still
have Merkel-tree fast verification, while being memory-hard.

I've been looking in more depth into Momentum.  It is very challenging to
come up with a workable Momentum PoW implementation that does not suffer
from significant speed penalties that would not be present in an FPGA or
ASIC attack.  The current GPU implementations seem to suffer a substantial
row-change delay penalty for most memory writes, which dominate the
runtime.  This would go away with an ASIC implementation with small on-chip
caches for radix-sorting.  I suspect we could beat the GPUs with an FPGA
implementation using the block-rams for the radix sort caches.  The point
of radix-sort caches is to enable large block-writes to external memory.
The GPU implementations randomly set 1 bit in 256MiB of shared memory until
about 1 bit in 16 is set.  I feel there is still plenty of work to be done
in this area.  So far, none of the existing PoW solutions with fast
verification seem to achieve a level of ASIC resistance that would deter
ASIC mining, IMO.  The theory is there, but in practice, details like
hashing speed and cache-miss penalties dominate.

Bill

On Mon, Jul 13, 2015 at 11:04 AM, Dmitry Khovratovich &lt;
khovratovich&#64;...il.com&gt; wrote:

&gt; Hi Bill,
&gt;
&gt; thank you for reviewing our scheme.
&gt;
&gt; Before looking deeply into you suggested modification, just one idea. Did
&gt; you consider parallel hashing for building the Merkle tree? Since you
&gt; already employ, say, 4 cores for multi-threaded Argon2d, how about using
&gt; them for Blake2bp? The designers report about 6x-speedup compared to the
&gt; single-core version <a href="https://blake2.net/blake2_20130129.pdf" rel="nofollow">https://blake2.net/blake2_20130129.pdf</a> , so this
&gt; should be about 0.5 cycles per byte, even faster than Argon2d.
&gt;
&gt; Best regards,
&gt; Dmitry
&gt;
&gt; On Tue, Jul 7, 2015 at 1:34 AM, Bill Cox &lt;waywardgeek&#64;...il.com&gt; wrote:
&gt;
&gt;&gt; First, kudos to the Argon team.  SFAIK, their algorithm actually works,
&gt;&gt; and is the only published memory-hard PoW that actually does.  However, I
&gt;&gt; don't think it's ready for use, yet.
&gt;&gt;
&gt;&gt; In short, their algorithm is to build a Merkel hash tree for all of the
&gt;&gt; memory filled with their memory-hard hashing algorithm.  It is generic, and
&gt;&gt; can be applied to any of the memory-hard algorithms.  They essentially do
&gt;&gt; this poof of work algorithm &lt;<a href="http://eprint.iacr.org/2007/433.pdf" rel="nofollow">http://eprint.iacr.org/2007/433.pdf</a>&gt;, but
&gt;&gt; with the leaves replaced with the memory contents after the memory-hard
&gt;&gt; hashing algorithm runs.
&gt;&gt;
&gt;&gt; The biggest problem I see is that they have to hash all the data, with a
&gt;&gt; full cryptographically strong hash function.  Any data not fully hashed is
&gt;&gt; not cryptographically tied to the Merkel hash root, and could be forged.
&gt;&gt; The full Blake2b is fast, but this additional post-memory-hashing Merkel
&gt;&gt; tree building step will dominate the runtime on any CPU.  Worse, an ASIC
&gt;&gt; attacker will get something like a 10X to 30X performance boost in this
&gt;&gt; step, with lower power consumption.  This is disastrous, because the main
&gt;&gt; point of memory-hard PoW systems is to reduce the advantage gained by using
&gt;&gt; custom ASICs.
&gt;&gt;
&gt;&gt; I do not see any solution on x86 processors other than to use the built-in
&gt;&gt; crypto instructions
&gt;&gt; &lt;<a href="http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/haswell-cryptographic-performance-paper.pdf" rel="nofollow">http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/haswell-cryptographic-performance-paper.pdf</a>&gt;
&gt;&gt; to reduce the difference in performance relative to ASICs.  What would the
&gt;&gt; best primitive be to use in this case?
&gt;&gt;
&gt;&gt; The SHA256 instructions seems pretty slow, at 2.67 cycles per byte.  I
&gt;&gt; suspect an ASIC will run much faster.  AES-GCM-encrypt is reasonably fast
&gt;&gt; at 1.26 bytes per cycle, with a resulting 128-bit authentication tag.
&gt;&gt; However, that's still too slow.  PHC finalists Argon2, Lyra2, and Yescrypt
&gt;&gt; all max out my 25GiB/s memory bandwidth when running enough threads.  I
&gt;&gt; wont be able to do that using any of Intel's crypto primitives and full
&gt;&gt; cryptographic hashing.
&gt;&gt;
&gt;&gt; One improvement to the Argon2 PoW algorithm would be to have a
&gt;&gt; memory-hard main loop like:
&gt;&gt;
&gt;&gt;     mem[0] = H(digest, nounce)
&gt;&gt;     for i = 0 to memSize-1 {
&gt;&gt;         randAddress = mem[i-1] % i;
&gt;&gt;         mem[i] = H2(mem[i-1], mem[randAddress]);
&gt;&gt;     }
&gt;&gt;
&gt;&gt; This is very similar to the current Argon2d loop, but the block hashing
&gt;&gt; is replaced with H2, which could be SHA256(a, b), for example.  After
&gt;&gt; filling memory, the final hash value  written is the Merkel hash root.  Use
&gt;&gt; it to compute a random path of length L from the root to mem[0].  So long
&gt;&gt; as L is secure number of hops, like (128?), then then hashes used to "open"
&gt;&gt; mem[0] should constitute a secure proof that the memory-hard hashing
&gt;&gt; algorithm has been run.
&gt;&gt;
&gt;&gt; In comparison to the Argon2 current PoW system, this performs half the
&gt;&gt; number of full hashes, since the Merkel tree is embedded in the data used
&gt;&gt; to fill memory, rather than computed as a post-process.  This should enable
&gt;&gt; it to have a 4x higher memory*time defense if memory bandwidth bound.  The
&gt;&gt; proof would be about the same length (num-bits of security times hash
&gt;&gt; length).  However, it is no longer generic like the current Argon2 PoW
&gt;&gt; algorithm.  Also, Argon2's algorithm is more familiar to people who know
&gt;&gt; about the Merkel hash tree PoW algorithm.
&gt;&gt;
&gt;&gt; Even with a 2X speedup and Intel crypto-intstructions, the algorithm is
&gt;&gt; not close to filling my CPU's I/O bandwidth.  A GPU might do better, but an
&gt;&gt; ASIC can do it faster and at far lower power.  I think these memory-hard
&gt;&gt; PoW algorithms with fast verification are not quite ready for prime-time.
&gt;&gt; Can anyone see a solution to the speed problem?  If ASICs will be a lot
&gt;&gt; faster and lower power, then there's no point using the algorithm, IMO.
&gt;&gt;
&gt;&gt; Bill
&gt;&gt;
&gt;
&gt;
&gt;
&gt; --
&gt; Best regards,
&gt; Dmitry Khovratovich
&gt;

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
