<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] Interest in specification of modular crypt format</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="2">[&lt;prev]</a> <a href="4">[next&gt;]</a> <a href="2">[&lt;thread-prev]</a> <a href="4">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;20150927185214.GA21050&#64;openwall.com&gt;
Date: Sun, 27 Sep 2015 21:52:14 +0300
From: Solar Designer &lt;solar&#64;...nwall.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] Interest in specification of modular crypt format

Hi Anthony,

Thank you for sharing your opinion.

On Sun, Sep 27, 2015 at 09:40:50AM -0400, Anthony Ferrara wrote:
&gt; Please, can the encoding be kept human-readable?

Maybe.  At least I've counted your vote. ;-)

&gt; Going with one-off encodings does look elegant,

What do you mean by one-off here?  That no other hashing scheme would
use the same encoding?  Ideally, we'd come up with an encoding, whether
human-readable or not, that multiple schemes would adopt.

&gt; but it makes the implementation significantly more error prone.

Does it?  Maybe that depends on the kind of errors you care about vs.
disregard.  In my proposed numeric encoding, I am focusing on having
implementation errors detectable in normal encoding/decoding of valid
inputs, or being impossible (e.g., can't overflow an int, can't encode
the same parameter more than once).  With a human-readable encoding like
Thomas', there are less critical potential errors that, on the other
hand, would tend to go undetected for long.  Even if the spec has lots
of MUST's and MUST NOT's, implementations will end up parsing strings
like p=1,t=2,p=3 (is it p=1 or p=3, then? parsing will vary between
implementations, and only a handful will actually reject such strings).

&gt; People are even confused by the fact that the salt-boundary in bcrypt
&gt; occurs mid-character (leading to only 4 possible character values for
&gt; the last salt character).

Yes, and I have no good solution for that one (short of the workaround
of using multiples of 6 for bit sizes of salts and hashes, or for
salts+hashes combined as Alexander Cherepanov mentioned to me off-list).

So it's a problem common for compact and verbose encodings, and not a
reason to choose one over the other.

&gt; Instead, can we focus on readability?

I'd be happy to, but it comes with drawbacks.  Such as:

&gt; For parameters that have well
&gt; defined defaults, simply don't require that parameter to be specified.

This means the encoding is not deterministic.  A parameter can be
omitted, or it can be explicitly included with its default value.

That's bad.  There's value in having canonical encodings, and in there
being only one canonical encoding for a given set of parameters, salt,
and hash.

If we change "don't require that parameter to be specified" to "require
that parameter not to be specified", that's better, but then many
parsers will not actually enforce this rule.  Maybe that's a minor
enough issue to accept it.  (The issue with multiple specification of a
parameter is worse.)

&gt; For those that don't have well defined defaults, then always require
&gt; them. Yes, it is a little bit more parsing overhead on the crypt()
&gt; implementation, but it greatly reduces the overhead on the calling
&gt; code. Especially for those building wrappers (which happens all the
&gt; time).
&gt; 
&gt; I do like the approach of specifically identifying parameter that was
&gt; brought up in the other thread. Something along the lines for scrypt:
&gt; 
&gt;     $7$n=14;r=8;p=1$ALotOfSalt$Hash
&gt; 
&gt; But since p=1 could reasonably be default, the following is identical:
&gt; 
&gt;     $7$n=14;r=8$ALotOfSalt$Hash
&gt; 
&gt; Whether a parameter is power-of-2 or base 10 would depend on the
&gt; algorithm. Also, please don't define the parameter order as rigid.
&gt; It's simple enough to implement arbitrary order, so why put arbitrary
&gt; restrictions?

Deterministic canonical encoding.  Side-stepping the issue of multiple
specification of a parameter (as long as the parser actually rejects
encodings with parameters appearing in unexpected order).

&gt; So my overall suggestion is make it easier on the developer using the
&gt; API, rather than the one writing it. After all, there are going to be
&gt; FAR more people writing a salt string then there will be writing the
&gt; backend implementation. Optimize for the greater use-case...

This makes sense to me.  We will need to provide an API for generating
salt strings (or "setting strings", as they're called for bsdicrypt and
on) anyway, but you have a valid point that, especially if the encoding
is simple for an application developer to understand, many developers
will be generating such strings on their own.

For PHP and such, I think this pretty much implies the encoding will
also need to use RFC Base64.  Then it's just sprintf of some decimal
numbers and some base64()'s.  So my point remains that Thomas' proposed
encoding is neither here nor there.

Thanks again,

Alexander
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
