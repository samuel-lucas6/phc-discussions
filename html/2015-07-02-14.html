<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] RE: Password hashing as a self-overwriting Turing machine</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="13">[&lt;prev]</a> <a href="15">[next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;1865628343-3164&#64;skroderider.denisbider.com&gt;
Date: Thu, 2 Jul 2015 17:35:55 +0100
From: denis bider &lt;pwhashing&#64;...isbider.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] RE: Password hashing as a self-overwriting Turing machine

&gt; Taking this line of reasoning further, it might be very cool to
&gt; randomly generate a set of op-codes that are commonly
&gt; available, and to compile them natively for execution.

This is the idea I wanted to convey, and I'm really glad it found an ear. :-)

There are practical difficulties that would make implementation more complex than my current design; the current BusyBeaver can be viewed as proof-of-concept.

But yes: I think *this* is the route to go in brute-force-resistant password hashing and proof-of-work in the long run. Ultimately, an algorithm based on this may likely be *the* solution.

Work has begun just this year on WebAssembly, which will attempt to combine the lessons of Google's Portable Native Client, and Mozilla's asm.js, into a single portable assembly standard supported by all major browsers. As soon as in 2-3 years, support for WebAssembly may be universal on mobiles and desktops.

Right now, an algorithm based on directly generating code would run into significant platform issues. The infrastructure for a single common instruction set is just not there, and it cannot be implemented just for password hashing. However, in a handful of years, there may likely be WebAssembly, with widespread infrastructural support. We'll be able to have a password hashing algorithm that spews out WebAssembly, and there will be infrastructure to run it on nearly every native platform.

If my idea found an ear, it could be argued that I made the submission at just the right time. The designs of current PHC candidates could very well be more appropriate for the current environment. However, an algorithm based on code generation may be the obvious choice in a few years, and now is the time to start thinking about that. :-)

denis


-----Original Message----- 
From: Bill Cox 
Sent: Thursday, July 2, 2015 09:17 
To: discussions&#64;...sword-hashing.net 
Subject: Re: [PHC] RE: Password hashing as a self-overwriting Turing machine 

On Wed, Jul 1, 2015 at 11:13 AM, Marsh Ray &lt;maray&#64;...rosoft.com&gt; wrote:

&gt; Well, I'm not a computer scientist. Maybe there are a few on the list that
&gt; can chime in.
&gt;
&gt; But it seems to me that there are two possibilities: either your machine
&gt; does data dependent branching, or it does not. The 'data' being derived
&gt; from the password.
&gt; * If it does allow data dependent branching, then you need to worry about
&gt; branch timing side channels leaking information about the password.
&gt; * If it does not allow data dependent branching, then you don't get to use
&gt; the halting problem as proof of irreproducibility.
&gt;
&gt; In other words, what is the advantage of executing a randomized stream of
&gt; operations over, say, performing a large block encryption using the salt as
&gt; key? The latter is something the defender's hardware may be able to help
&gt; with.
&gt;

Executing truly random machine instructions on the defender's machine will
be essentially impractical to make go faster than a good CPU ran run them,
even with a custom ASIC.  If it were easy to do, the CPU manufacturer would
have done it.

In contrast, an attacker's custom ASIC would heavily pipeline the
encryption hardware, attempting many password guesses in parallel.  That's
why we need the large memory for hashing.

Taking this line of reasoning further, it might be very cool to randomly
generate a set of op-codes that are commonly available, and to compile them
natively for execution.  This is not entirely unlike how the fastest circle
drawing code used to write it's own machine code based on the circle
parameters, and then execute it.

BusyBeaver could have been an educational and entertaining entry :-)  I can
think of a lot of fun directions to go with this.

Bill


<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
