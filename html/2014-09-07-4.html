<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] A review per day - Lyra2</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="3">[&lt;prev]</a> <a href="5">[next&gt;]</a> <a href="../../../2014/09/06/6">[&lt;thread-prev]</a> <a href="5">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;20140907150526.GA9022&#64;openwall.com&gt;
Date: Sun, 7 Sep 2014 19:05:26 +0400
From: Solar Designer &lt;solar&#64;...nwall.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] A review per day - Lyra2

Bill,

Thank you for comparing these three candidates.

On Sat, Sep 06, 2014 at 10:44:21AM -0400, Bill Cox wrote:
&gt; Yescrypt wins at GPU defense, due to it's rapid unpredictable small
&gt; memory reads from L1 cache.  Like bcrypt, Yescrypt issues multiple
&gt; unpredictable small memory reads in parallel, to get to about 1/2 the
&gt; number that bcrypt does

Where did you get the specific "1/2" figure from?  Does it possibly come
from that posting on "escrypt 0.3.1"? -
<a href="http://thread.gmane.org/gmane.comp.security.phc/959/focus=1009" rel="nofollow">http://thread.gmane.org/gmane.comp.security.phc/959/focus=1009</a>
If so, please note that current yescrypt, as submitted to PHC, has
changed in this respect since then, to match bcrypt more closely in this
respect.  In that posting, I specifically said that those initial
benchmark results vs. bcrypt demonstrated that more work was needed.

&gt; when single-threaded.

What do you mean by that?

The comparison vs. bcrypt only makes sense when we're exhausting all CPU
cores by both bcrypt and the PHC candidate being tested.  This means
running as many concurrent instances (yes, single-threaded ones) as
there are logical CPUs in the system (so multiple threads total).

Purely single-threaded comparisons are not relevant, neither for the
defender (where the bcrypt cost setting and the PHC candidate's cost
settings will be limited by server capacity), nor for the attacker (who
will typically want to use their resources fully at all times).

&gt; TwoCats only issues one
&gt; unpredictable read at a time, and performs them at about 1/3 the
&gt; number as bcrypt when single threaded.  However, Yescrypt is designed
&gt; to max out everything at the same time, including CPU cores, while
&gt; TwoCats runs into memory bottlenecks on my test machine using only
&gt; half the CPU cores.  This gives Yescrypt a 3X-ish advantage over
&gt; TwoCats in unpredictable read rate, which likely translates into
&gt; better GPU defense.

Oh, OK.  So you do acknowledge the single-threaded scenario isn't one to
consider in this context.

&gt; Lyra2 does small-ish unpredictable reads,

Where?  I am not seeing that.  I only see 3 nested loops: Time Loop
until T (corresponds to yescrypt's t), Visitation Loop for rows
(corresponds to (ye)scrypt SMix second loop), and Columns Loop
(corresponds to (ye)scrypt's BlockMix).  There's nothing that would
correspond to yescrypt's pwxform, as far as I can see.  Setting C low
would be equivalent to setting scrypt's r low - that is, it would bring
things closer to a Pufferfish-alike, but not close enough for this to
make sense (so memory access would become slow, but not much GPU defense
would be achieved).

&gt; ASIC defense for large memory hashing is excellent for all three,
&gt; assuming Lyra2 becomes multi-threaded.  An ASIC attacker will quickly
&gt; become memory bandwidth limited.  Practical ASIC attacks have at most
&gt; about a 32 times higher memory bandwidth than a modern high-end CPU.
&gt; This enables an attacker to run up to 32 times faster, but the expense
&gt; per ASIC of such a system is likely similar to the cost of a desktop
&gt; PC.  TwoCats and Yescrypt have multiplication chain compute-time
&gt; hardening, which in some cases will limit an attacker's ability to
&gt; hash at the full speed supported by his memory bandwidth.  In that
&gt; case, Yescrypt and TwoCats will force an attacker to either make fewer
&gt; guesses per second, or buy more memory so that more attacks can be
&gt; interleaved, filling up memory bandwidth.  Yescrypt and TwoCats win
&gt; over Lyra2 because of this.  TwoCat's multiplication chains are
&gt; tunable, allowing it to tune the multiplication chain lengths to the
&gt; hashing speed of the machine.  This allows TwoCats to be more
&gt; multiplication chain hardened than Yescrypt in some cases.  The extra
&gt; area on the ASIC needed by Lyra2 and Yescrypt computation logic vs
&gt; TwoCats is tiny, as there would only be 32 copies at most.  TwoCats
&gt; has a slight win here over Yescrypt.

I intend to look into making yescrypt's pwxform rounds count tunable,
e.g. maybe supporting 2, 6, 10, 14 rounds (two flag bits).  (The current
hard-coded default is 6.)  In semi-optimized code, this may be 2 rounds
followed by a loop with 4 rounds in it, or vice versa, or it may be a
loop with 4 rounds in it and an exit from the middle of the loop's body.
6 is what I find optimal on current servers for user authentication,
2 may provide better single-threaded performance (but lower
multiplication latency hardening), closer to TwoCats'.  10 and 14 may
provide higher multiplication latency hardening.

Do you feel this would be worth the extra complexity?

&gt; It may be common for some groups of users to run single-threaded,
&gt; though I recommend against it in all cases except for single-core
&gt; CPUs.  In that case, TwoCats wins in ASIC defense simply because it
&gt; will fill more memory than either Lyra2 or Yescrypt.  A single TwoCats
&gt; thread fills external memory over twice the speed of either Yescrypt
&gt; or Lyra2.  When no SIMD unit is available, that ratio might increases
&gt; by a factor of about 4, corresponding to the pipeline depth used in
&gt; the SIMD units by Yescrypt and Lyra2.

&gt; While all three have no requirement for special hardware, all three
&gt; are tuned for modern x86 SIMD units.  TwoCats I think wins in
&gt; adaptability to basic CPUs.  This is because it can run with a single
&gt; 32-bit width with far fewer instructions per byte of memory hashed.
&gt; Yescrypt also has variable width SIMD loops, but it's pipeline depth
&gt; is not currently variable, making it slow down somewhat on a basic
&gt; CPU.  TwoCats wins here because it uses less pipelined parallelism.

Yes, I need to make yescrypt's instruction and SIMD parallelism runtime
tunable, supporting a handful of settings.

&gt; Lyra2 easily wins at TMTO defense.  Both Lyra2 and Yescrypt use
&gt; increasing t_cost to improve TMTO defense, but Lyra2's decision to
&gt; continue overwriting memory while reading I think makes it more TMTO
&gt; resistant.

yescrypt also continues overwriting memory while reading, except when
run with high p (which Lyra2 doesn't currently support) and the
YESCRYPT_PARALLEL_SMIX flag set.  When p &gt; 1 and YESCRYPT_PARALLEL_SMIX
is set, yescrypt avoids writes during the portion of its running time
where all threads share the entire V.  Even in that case, increasing t
also increases the number of loop iterations during which writes do
happen (although this number is relatively small when p is high).

&gt; TwoCats as submitted uses t_cost poorly.  A revised
&gt; version exists that will be submitted if allowed, which does increase
&gt; TMTO resistance as t_cost increases, but this feature works better in
&gt; Lyra2 and Yescrypt.  However, because TwoCats was designed as a single
&gt; pass algorithm, it has the best TMTO resistance when t_cost turned
&gt; off, meaning only one memory pass.  This is not a mode Lyra2 allows,
&gt; but Yescrypt does, and both Yescrypt and TwoCats achieve higher
&gt; memory*time defense as a result.

yescrypt doesn't support fully skipping its SMix2.  t=0 corresponds to
spending 1/4 of yescrypt's total running time in SMix2.

&gt; As for time*memory defense, Yescrypt, when run with t_cost == 0, has
&gt; the same characteristics as TwoCats, filling memory linearly, never
&gt; stopping until enough memory has been hashed.

No.  See above.

&gt; This maximizes time*memory defense vs any other possible solution.

It does, but there are also concerns on the (non-)uniformity of memory
accesses, which may enable attacker's dollar cost optimizations via use
of different memory types.  You partially deal with this (and with TMTO)
via your "cubed distribution".  yescrypt deals with it via sliding power
of 2 window, but this moves the optimal stopping point for its scrypt
SMix-like algorithm from N (just first loop) to 4/3*N (1/4th of total
time spent in SMix's second loop).  We discussed this in here some
months ago.

&gt; Lyra2 does at
&gt; least two passes over memory, doing twice as many read/write
&gt; operations per memory location.  This causes it to use half the memory
&gt; as TwoCats and Yescrypt when memory bandwidth limited.  All of my ASIC
&gt; attack plans so far would need only half the memory to attack Lyra2
&gt; hashes, lowering it's time*memory defense by 2X.  However, a more
&gt; sophisticated attack might be able to take advantage of the unfilled
&gt; memory until it is needed, lowering the time*memory penalty to only a
&gt; 3/4ths of TwoCats and Yescrypt.

For TwoCats, average usage is 1/2 of peak.  I guess you derive 3/4 of
TwoCats' for Lyra2 given that Lyra2's average is also naturally somewhat
lower than its peak usage, just not to the same extent.

For yescrypt t=0 in native mode, average usage is 5/8 of peak.

Alexander
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
