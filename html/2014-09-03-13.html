<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] Argon is highly parallelizable...</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="12">[&lt;prev]</a> <a href="14">[next&gt;]</a> <a href="../../../2014/08/27/1">[&lt;thread-prev]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CALW8-7Kvq-fcfwRRdAhPHVr_QPh_AJWTxmCTHphAuOK==e-YUw&#64;mail.gmail.com&gt;
Date: Wed, 3 Sep 2014 16:23:52 +0200
From: Dmitry Khovratovich &lt;khovratovich&#64;...il.com&gt;
To: "discussions&#64;...sword-hashing.net" &lt;discussions&#64;...sword-hashing.net&gt;
Subject: Re: [PHC] Argon is highly parallelizable...

Hi Bill,

thank you for the analysis.

Argon indeed allows different sorts of parallelism. The one you noticed in
ShuffleSlices is not documented in the submission, but it is used in our
tradeoff energy estimates (and you can see it on slides).

In the ASIC energy model it benefits the attacker only slightly, actually,
since it keeps the read/write energy and the AES computation energy
untouched, and only the retention energy may be reduced. However, for such
high bandwidth the retention energy will likely to be dominated by the
active energy, so the actual win would be tiny.

Also, the parallelism in ShuffleSlices is helpful only in running the
password cracking with no memory reduction, i.e. with no tradeoff. Even if
the memory is reduced by the factor of two, the scheme latency will
increase much more due to the need to run a stack of AES's to recompute the
entry in ShuffleSlices.

A defender might be able to use this parallelism to hide the memory access
pattern if there is a concern about cache-based timing attacks. Indeed, as
many as 2^15 AES states can be read in parallel in an arbitrary order. The
defender generates a random permutation of this size and reads the states
from the memory according to it. The consequences are different for
different types of adversary, but the cross-VM attacks will definitely have
much lower signal-to-noise ratio due to the increased uncertainty in the
cache contents.

Best regards,
Dmitry


On Tue, Aug 26, 2014 at 8:18 PM, Bill Cox &lt;waywardgeek&#64;...hershed.org&gt;
wrote:

&gt; The SubGroup call is "embarrassingly parallelizable", meaning for N
&gt; blocks of 32 128-bit state values, we can run it in parallel N ways.
&gt; Each "SubGroup" hash on groups of 32 128-bit states is independent from
&gt; the others.
&gt;
&gt; The ShuffleSlices is parallelizable well beyond the intended 32-way
&gt; parallelism.  First, run all 32 slices in parallel.  Then, for each
&gt; slice, compute many sequential j values in parallel.  This is not a
&gt; problem if we build a custom cache that presents many sequential state
&gt; values at once to each slice computation unit.  Parallel addition of
&gt; all the j values is then a simple matter,  Once they are computed, we
&gt; can compute the destination addresses for swapping in parallel, and
&gt; even do the swapping in parallel with our custom cache.  The only
&gt; problem is if any destination j address is within the set of states we
&gt; added together in parallel, in which case we abort and do this group
&gt; in sequentially.
&gt;
&gt; With the right choice for number of j values, aborting should not
&gt; happen often enough to reduce the runtime.  For an extra 16-way
&gt; parallelism on a 16MiB hash (total of 512 parallel cores, since we
&gt; have 32 parallel slices), only about 1 in 128 blocks of 32 would have
&gt; to be computed sequentially.
&gt;
&gt; Memory bandwidth could be a limiting factor, but a cache architecture
&gt; for delivering 32 pseudo-random values in parallel is doable with
&gt; reasonable latency.
&gt;
&gt; Not only that, but Argon can be run in constant time and memory with
&gt; cache timing data, regardless of m_cost and t_cost settings.  An
&gt; attacker only needs to hash the first 512 bytes before he can
&gt; replicate data dependent reads.  This is a far worse parallel attack
&gt; with cache timing data than the one the Catena paper outlined against
&gt; Script.
&gt;
&gt; I had not realized that the Argon authors claimed that t_cost == 3 is
&gt; the minimum safe number of rounds for 1GiB, and for 10MiB, it was 236.
&gt;  Running the benchmarks again with these numbers:
&gt;
&gt; 10MiB case:
&gt;
&gt; Linux-AES-NI&gt; time Argon-Optimized -taglength 32 -logmcost 10 -tcost
&gt; 234 -pwdlen 64 -saltlen 16 -threads 5
&gt; Memory allocated: 1 MBytes, 5 threads
&gt; Argon:  346.15 cpb 338.04 Mcycles 0.3923 seconds
&gt;
&gt; real    0m0.106s
&gt; user    0m0.347s
&gt; sys     0m0.047s
&gt;
&gt; 1GiB case:
&gt;
&gt; Linux-AES-NI&gt; time Argon-Optimized -taglength 32 -logmcost 20 -tcost 3
&gt; -pwdlen 64 -saltlen 16 -threads 8
&gt; Memory allocated: 1024 MBytes, 8 threads
&gt; Argon:  13.25 cpb 13250.55 Mcycles 18.4738 seconds
&gt;
&gt; real    0m4.097s
&gt; user    0m18.329s
&gt; sys     0m0.146s
&gt;
&gt; I claim my 7ms TwoCats hash of 16MiB is far more secure against brute
&gt; force off-line guessing attacks, with or without cache timing data.
&gt; Given a full 100ms, I'd hash over 500MiB on this machine, providing
&gt; even more security.  Yescrypt can do this just as fast, when
&gt; appropriate settings are used.  Lyra2 does pretty well, though not as
&gt; fast.
&gt;
&gt; Bill
&gt;



-- 
Best regards,
Dmitry Khovratovich

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
