<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] On Delegation (Was: "Why I Don't Recommend Scrypt")</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="18">[&lt;prev]</a> <a href="../../../2014/03/23/1">[next&gt;]</a> <a href="../../../2014/03/15/6">[&lt;thread-prev]</a> <a href="../../../2014/03/23/4">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;20140322233142.GA26682&#64;openwall.com&gt;
Date: Sun, 23 Mar 2014 03:31:42 +0400
From: Solar Designer &lt;solar&#64;...nwall.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] On Delegation (Was: "Why I Don't Recommend Scrypt")

Thomas,

I'm sorry for not replying to this message sooner.  My excuse is that it
got a bit long (covering several topics at once), and I didn't have an
e-mail moment long enough until now. ;-)

On Sat, Mar 15, 2014 at 01:19:24AM +0100, Thomas Pornin wrote:
&gt; On Fri, Mar 14, 2014 at 11:42:41PM +0400, Solar Designer wrote:
&gt; &gt; As I mentioned before, I think a shortcut like this could be used for
&gt; &gt; more effective memory cost upgrades than what e.g. Catena provides.
&gt; 
&gt; I envision the "fast path" to be adequate to situations where there are,
&gt; say, several login servers feeding on the same database of hashed
&gt; passwords but offering different services, and one of them can be
&gt; entrusted with a private key which allows for (much) faster password
&gt; verification for some reason, e.g. because it has an HSM while other
&gt; frontends do not. Or something like that.
&gt; 
&gt; In any case, a fast path can be retrofitted to any password hashing
&gt; function by the simple expedient of storing both the hash value AND an
&gt; asymmetric encryption of the password (or of SHA-256(password) or
&gt; anything similarly fast) with some public key; a system which has a copy
&gt; of the private key can forget the hash and use decryption to recover the
&gt; password (or its fast hash). Without the private key, the public-key
&gt; encrypted password is useless (normal asymmetric encryption algorithms
&gt; are randomized, so that cannot be used for enumerating passwords). Such
&gt; a scheme implies a storage overhead which needs not be large (with
&gt; EC-based ElGamal or ECIES, this could be done with, say, 50 bytes
&gt; overhead per stored password).
&gt; 
&gt; (I don't follow what you mean by memory cost upgrades in the context
&gt; of a "fast path" so I fear we may not be speaking of the same thing.)

Yes, I was speaking of a different thing:

<a href="http://lists.randombit.net/pipermail/cryptography/2012-November/003451.html" rel="nofollow">http://lists.randombit.net/pipermail/cryptography/2012-November/003451.html</a>

"A much trickier task: support upgrades to a higher memory cost for the
already-computed iterations.  Sounds impossible at first?  Not quite.
This would probably require initial use of some secret component
(allowing for a lower-memory shortcut) and then dropping it at upgrade
time."

&gt; Anyway, both the ability to increase the cost parameter from the hash
&gt; value alone (without access to the source password), and the "fast
&gt; path", are straight from the PHC call for submissions:
&gt; 
&gt;   | Ability to transform an existing hash to a different cost setting
&gt;   | without knowledge of the password.

Yeah.  I think it came from my 2012 slides.  (I don't know if it was
listed among desired properties for password hashes before that time.)

&gt; and:
&gt; 
&gt;   | For example, one may design a scheme that is slow to evaluate
&gt;   | except on a server given some server-specific shortcut.

I think this was Jean-Philippe Aumasson's idea, unless he got it from
somewhere else.

&gt; Since these properties were listed as desirable, I kind of assumed that
&gt; they were desired.

Yes, at least the hash cost upgrades are desirable.  I'd say they're a
must for new non-memory-hard hashes (although this is not a strict
requirement for PHC submissions), because for those this is strictly
beneficial.  For memory-hard hashes, upgrading works somewhat worse than
computing a new hash, so the feature is somewhat less desirable.

&gt; &gt; &gt; Or even more advanced features such as the ability to
&gt; &gt; &gt; delegate computation to an external untrusted system.
&gt; &gt; 
&gt; &gt; This is an interesting topic, which somehow we haven't touched on this
&gt; &gt; list yet, although at least Jeremy Spilman and I thought of it before.
&gt; &gt; 
&gt; &gt; Arguably, it falls in the same category as hash upgrades and client-side
&gt; &gt; pre-hashing, because it can also be implemented on top of an existing
&gt; &gt; password hashing scheme lacking this feature as a built-in one
&gt; 
&gt; Now I am all ears.
&gt; 
&gt; Background: my own candidate (which I submitted three weeks ago) offers
&gt; cost parameter increase, a fast path, and delegation.

Being on the panel for PHC, I am aware that you made this submission
(thank you!), but I did not look at it closely yet because (1) I didn't
have time for that yet, and (2) you didn't make it public yet, which
might be deliberate, so I didn't want to be "exposed" to it yet (given
my plans to possibly make a PHC submission too).  So I was unaware of
what features it had.

&gt; Delegation to an
&gt; _untrusted_ external system seems quite non-trivial to me, and I found
&gt; only one way to achieve it, which involves some maths.

For the functionality you describe below, I'd be thinking along the
lines of RSA blinding - and yes, it'd need to be part of the password
hashing scheme.

&gt; I do not see how
&gt; it could be implemented "on top of an existing password hashing scheme".
&gt; So if you have a method for that, I am VERY interested.

I was thinking of the same use case that Jeremi described, where the
salt (or at least one of the salts if there are several) could be kept
private to the trusted authentication server.

Your example with SRP requires a more complicated approach, yes.

&gt; &gt; &gt; the output is 192 bits only,
&gt; &gt; 
&gt; &gt; 184, and that's more than enough.
&gt; 
&gt; Technically, bcrypt is a custom 64-bit block cipher with a very long key
&gt; schedule, which is then used to encrypt a 192-bit input (exactly three
&gt; blocks). If it is limited to 184 bits, it is as an artefact of ulterior
&gt; encoding (Base64, 31 _characters_ instead of 32, so you really get 186
&gt; bits, not 184).

184 instead of 192 is because of a bug.  Since the bug had no security
impact, a decision was made in 1998 to keep things that way and cleanup
the code, so that this (weird yet harmless) behavior is explicit:

<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/lib/libc/crypt/bcrypt.c.diff?r1=1.11;r2=1.12" rel="nofollow">http://www.openbsd.org/cgi-bin/cvsweb/src/lib/libc/crypt/bcrypt.c.diff?r1=1.11;r2=1.12</a>

&gt; If you need more than 128 bits, then that's for a KDF,
&gt; and in that case there is no point in applying the Base64 encoding and
&gt; its historical shortcomings at all, so you would get the full 192 bits.

True, but until last year bcrypt was only defined for password hashing,
with the encoding.  bcrypt-pbkdf was introduced last year (2013) and it
differs in a few more ways than just not having the encoding:

<a href="http://www.tedunangst.com/flak/post/bcrypt-pbkdf" rel="nofollow">http://www.tedunangst.com/flak/post/bcrypt-pbkdf</a>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/lib/libutil/bcrypt_pbkdf.c" rel="nofollow">http://www.openbsd.org/cgi-bin/cvsweb/src/lib/libutil/bcrypt_pbkdf.c</a>

&gt; &gt; The actual limit is 72 chars.  56 is an error in the bcrypt paper, and
&gt; &gt; it's repeated in the scrypt paper and elsewhere.
&gt; 
&gt; Well, the authors of bcrypt specified it as using 56 bytes, so I would
&gt; say that the "error" is 72, not 56 -- by definition.

This depends on whether the reference code (in OpenBSD since 1997) or
the paper (USENIX 99) prevails.  In this case, it's clear that the code
prevails, and the "errors" (not just this one) are in the paper.  Other
implementations of bcrypt try to match OpenBSD's, not the paper.  The
paper does not provide a complete spec anyway, not giving the exact hash
encoding.  The code in OpenBSD is the spec.

&gt; Although it can be
&gt; argued that the algorithm "works" for longer inputs, one could say that
&gt; the "official" bcrypt (with appropriate double quotes around "official")
&gt; is the one which the paper defined, because that is the one which got
&gt; theoretically reviewed by other cryptographers.

One could argue, but upstream's (OpenBSD) position is that the code in
OpenBSD is the spec (and I think they are right).  The paper is not.

&gt; The "56" comes from the fact that bcrypt is derived from Blowfish, which
&gt; uses keys of up to 56 bytes (and no more). However, a longer key would
&gt; fit in Blowfish as well.

Right.

&gt; If we say that limiting bcrypt to 56 bytes is
&gt; an error, then so is limiting Blowfish keys to 56 bytes.

Not necessarily.

&gt; &gt; &gt; practice more often 55 or 51 characters, depending on the implementation
&gt; &gt; &gt; library),...
&gt; &gt; 
&gt; &gt; Huh?!  I've never seen implementations of bcrypt like that.  Have you?
&gt; &gt; Got any pointers?
&gt; 
&gt; I'll have to dig a bit around; it is old memory. The "51" apparently
&gt; comes from a faulty assumption in some usage somewhere of bcrypt that
&gt; the "55 bytes" included a 4-byte salt (which may have been true in some
&gt; variant). The "55 vs 56" is about the inclusion or not of a terminating
&gt; 0.

OK, but the salt is 128-bit, is not included in the same input as the
key (so does not reduce max key length), and the terminating NUL does
not limit the key length (rather, in $2a$ and newer it's included in the
expanded key so that e.g. "ab" and "abab" don't hash to the same thing).
With a string of &gt;= 72 chars, the terminating NUL does not get into the
expanded key (there's no need).  That's how bcrypt has been defined
since 1997, via the code in OpenBSD.

&gt; &gt; I also don't think so, but I also don't think the portfolio should be
&gt; &gt; large.
&gt; 
&gt; Last I heard, some rumours talked about a dozen candidates or so, which
&gt; is not much (but it is also rumoured that rumours occasionally turn out
&gt; to be off by a long shot). This could yield a portfolio of, say, three
&gt; or four schemes.

OK.  I was hoping there'd be just two schemes in the portfolio: one for
native code (and for VMs similar to actual CPUs) and one for scripting
languages like PHP (where some native code crypto primitives might be
available, but any other non-trivial processing would be slow).
However, now it does sound like three or four could be appropriate,
given the non-overlap of use cases and of feature sets between the
schemes mentioned so far - e.g., it does sound like your scheme's
delegation feature is unique.

&gt; In any case, when considering the AES and SHA-3 competitions, I usually
&gt; say that the greatest thing about them is not that they came up with a
&gt; good final choice, but that it also exposed a lot of backup schemes.

For PHC, I think the greatest thing is that it advances the field - by
so much that I think we'd benefit from having an extra round in PHC to
have an even greater chance to learn from each other and put that new
knowledge into revised submissions.

Alexander
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
