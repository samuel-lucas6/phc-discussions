<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Memory-hard proof of work with fast verification (CPU Hash)</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="2">[&lt;prev]</a> <a href="4">[next&gt;]</a> <a href="4">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CAOLP8p6J-7-ywziaYKdVJM9RubsvbQh1gzpO6yWcJxpFSq4vpg&#64;mail.gmail.com&gt;
Date: Sat, 4 Jul 2015 03:56:57 -0700
From: Bill Cox &lt;waywardgeek&#64;...il.com&gt;
To: "discussions&#64;...sword-hashing.net" &lt;discussions&#64;...sword-hashing.net&gt;
Subject: Memory-hard proof of work with fast verification (CPU Hash)

It turns out that Momentum has some devastating parallel attacks, and
should not be used.  IIRC, Cuckoo is also broken.  So, here's the outline
for a new algorithm I hope can help fix this situation.  As usual, I'll put
code on github.  I'm calling it CPU Hash for now.

The algorithm is motivated from EARWORM, using the fix I proposed to defeat
distributed ROM attacks (increasing the state size).  It uses a large
random ROM (maybe 512MiB), and a fairly small RAM (20KiB).

A large ROM is initialized with blocks of 4KiB each (this overcomes DRAM
latency issues caused by cache misses).  A fast block hash function
hashBlocks(digest, nounce, block1, block2) creates a new block from the
previous two.  I used a multiplication-chain compute-time hardened hash
function motivated from TwoCats/Yescrypt, followed by a cryptographic hash.

The initial block is copied from the first block, ROM[0], and the digest of
the crypto-coin block and nounce (guess for solution to crypto-coin block)
are copied to the start of the memory block.  Block b[1] is then hashed in
with hashBlocks.  If the resulting block final HLEN bytes hashes (with a
cryptographic hash) to less than the difficulty setting, then success, a
solution is found.  The proof of work is simply the new crpto-coin block
and nounce that solves it.  Verification simply repeats the hash of 20KiB,
which runs in constant time.  Since only 20KiB are hashed, and 8KiB is
usually already cached (ROM[0] and ROM[1]), this should be much faster than
LiteCoin in blockchain verification,  Also, my block hash is wicked fast :)

The main advantage is that the ROM will large enough to require external
DRAM, while verification speed is faster than in LiteCoin.  I think this is
the combination needed to discourage ASIC based mining, and keep mining on
CPUs.

Defeating GPU attacks is with the large ROM.  Scrypt achieves parity
somewhere around 4MiB.  This would be much larger, maybe 512MiB.

Highly parallel distributed ROM attacks using custom ASICs would be
defeated by hashing random blocks three times, which would require that two
of the blocks be transmitted from one node to another other over a
network.  The network routing for 2 blocks should be slower than a CPU
reading 3 blocks from DRAM.  Hashing more than one block is required,
because with just one block the index could simply be transmitted to the
node owning the ROM block, and computation could be done entirely by the
destination node.

The code is coming along, though the idea is only a few of hours old.
Maybe I'm too sleepy to think straight, but it seems to me that this is a
nice upgrade to the various crypto-coin PoW that are trying to make use of
memory-hard password hashing algorithms.  I'm too sleepy to see the flaws
at the moment.  Do you guys see any in this outline?

Thanks,
Bill

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
