<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] Lyra2 initial review</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="15">[&lt;prev]</a> <a href="17">[next&gt;]</a> <a href="15">[&lt;thread-prev]</a> <a href="17">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;1389701608.2588638.1397763983624.JavaMail.root&#64;larc.usp.br&gt;
Date: Thu, 17 Apr 2014 16:46:23 -0300 (BRT)
From: Marcos Antonio Simplicio Junior &lt;mjunior&#64;...c.usp.br&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] Lyra2 initial review

----- Mensagem original -----

&gt; De: "Bill Cox" &lt;waywardgeek&#64;...il.com&gt;
&gt; Para: discussions&#64;...sword-hashing.net
&gt; Enviadas: Quarta-feira, 16 de Abril de 2014 15:32:09
&gt; Assunto: [PHC] Lyra2 initial review

&gt; After reading some of the Lyra2 source code for pebbling, I got into
&gt; it a bit. Here's my initial thoughts.

&gt; First of all, I am impressed. If Lyra2 is chosen over Yescript and
&gt; TwoCats, I will not be upset, because password hashing security will
&gt; still have been significantly enhanced. Lyra2, in my view, after
&gt; fixing a few things, is good enough. I consider it the only other
&gt; strong generic high-memory hashing candidate besides Yescript and
&gt; TwoCats, as the others are either much slower, or have no strategy
&gt; for dealing with cache-miss penalties when hashing large amounts of
&gt; external DRAM. I call this the "Scrypt inspired" category in other
&gt; posts. I still feel that Yescript is a better platform for more
&gt; advanced features such as ROM, Bcrypt-like GPU defense, and
&gt; multi-threading with TMTO defense (forcing threads to run in
&gt; parallel), and I think Alexander can do better than either me or the
&gt; Lyra2 team at getting several of these fine points right. However,
&gt; if we're mainly looking for an improvement over Script, I think
&gt; Lyra2 delivers. It's very good work.

Yescript do have very interesting points we hope to address with the envisioned tweaks mentioned in the documentation. If we will actually get there, that is a whole different story... 

&gt; Here's some points I like. Being a speed freak, I like it's speed! It
&gt; has the second highest memory hashing speed for 1 thread, not
&gt; counting EARWORM, which is even faster, but a very different animal.
&gt; On my development machine (3.4GHz Core i7 Ivy Bridge running 64-bit
&gt; Arch Linix) the Lyra2 SSE version does, with t_cost == 1, and m_cost
&gt; == 100,000:

&gt; 1.47GiB/s of memory hashing (.57GiB/.39s) peak
&gt; 1.10GiB/s average
&gt; 4.41 GiB/s DRAM bandwidth

&gt; It fills memory for the 1st half, and overwrites memory in the second
&gt; half, so average memory usage is about 75% of peak for t_cost == 1,
&gt; which is how I would normally run Lyra2. For DRAM bandwidth, Lyra2
&gt; reads on average every location once, and writes it twice, for 3X
&gt; the memory size of total data transfer. For comparison, the fastest
&gt; version of Script is Alexander's Yescript when run in Script
&gt; compatibility mode. On my machine, it does:

&gt; 0.74GiB/s of memory hashing (2GiB/2.71s) peak
&gt; 0.56GiB/s average
&gt; 1.5GiB/s DRAM bandwidth

Whatever I say here I think is outdated given the other e-mails, but both in the Setup and Wandering phases we have: 

- two reads: the last row ever written upon, "prev", and an older (during the Wandering phase, random) row, named "row*" (or "row_a" in the wiki's pseudocode) 
- two writes: over the next row, named simply "row", and over "row*" previously read. Actually in the Setup phase this is a XOR with an existing value in row*, so technically we have 1 additional read here (although "row*" should be in cache already); also, during the Wandering phase the XOR affects both "row" and "row*", so we have 2 additional reads ("row*" likely being in cache and "row" being in cache only if the scheduler is smart enough to bring the required blocks to cache ahead of their usage). 

If I understood your benchmark on "memory hashing peak" and "average", it is actually quite lower than what we got in our machine: Figure 15 of the specification shows a running time of ~1.37s for 1.6 GB. So, (assuming my students are not lying to me ;-) ) the average memory hashing speed was ~1.17 GB/s. This is certainly influenced by the processor speed, but it may also be related to the value of the nCols parameter, which influences how Lyra2 explores cache: maybe if you try different values of nCols (we tested with 16 to 128, using a x2 step), you can get better results. 

&gt; Yescript maxes out bandwidth with extra threads, so this is not the
&gt; most critical benchmark. However, Lyra2's speed looks good! TwoCats,
&gt; with a custom memory hashing function rather than reduced-round
&gt; Blake2 or Salsa, is faster yet:

&gt; 3.85GiB/s of memory hashing (2GiB/.52s) peak
&gt; 1.92GiB/s average
&gt; 7.7GiB/s DRAM bandwidth

&gt; There's more that I like about Lyra2. It uses what I call a "hybrid:
&gt; architecture, where the first loop is cache-timing resistant and
&gt; does no password-dependent memory addressiong, and the second loop
&gt; is unpredictable and does password dependent addressing. This, in my
&gt; opinion, is the sweet-spot where we retain the strong memory*time
&gt; defense of unpredictable algorithms, while having some cache-timing
&gt; defense.

As I mentioned in another e-mail, this was actually a side effect, but I'm glad you liked it :-) 

&gt; I also like the custom blake2-b based sponge. This is quite a bit
&gt; faster than the Keccak based sponges used in other entries, and is
&gt; somewhat slower in hardware than Keccak, both of which help
&gt; defenders. The Lyra2 team got the PRK derivation right, and is a
&gt; "Strongly secure" algorithm, in that it hashes all the inputs and
&gt; their lengths, eliminating the input collisions I see in several
&gt; other entries.

To be honest, that is because you did not see v0... We spent too much time trying to get the TMTO right and forgot about trivial collisions in that version (it was just hashing pad(pwd || salt)). Dmitry Khovratovich (Thank you!!!) got that right for us in a private email. 

&gt; Not only is the custom sponge cool, but the Lyra2 team is one of the
&gt; few that bothered to do substantial SSE optimization up-front. When
&gt; designing TwoCats, I found that separating the design of the inner
&gt; hashing loop from SSE optimization was nearly impossible. You just
&gt; can't separate design and optimization. The Lyra2 team did design
&gt; and optimization at the same time, enabling them to achieve very
&gt; high speeds, which is something many of the other entries will not
&gt; be able to duplicate now that the design phase is mostly over.

I believe that most of the optimization came from allowing different parameters to be set. The more configurable you make your design, the easier to take advantage of its flexibility with hardware features, either current of future. 

&gt; There are also things I didn't like about Lyra2, and places where I
&gt; think Lyra2 needs improvement or fixing.

&gt; First, Lyra2 uses a modified version of Blake2b that only uses
&gt; ROUND(0) (I think - it may be a Lyra2-modified round). For the main
&gt; memory hashing, that's fine. Someone should check that it is mixing
&gt; well enough with just ROUND(0) - probably me! So long as an attacker
&gt; has to do the same computations, I don't care if the data written to
&gt; memory is cryptographically indistinguishable from random data. If
&gt; it is, I believe you're spending far too much CPU time hashing data
&gt; instead of filling memory. However, as Alexander put it, there's no
&gt; excuse for doing a billion-long chain of non-cryptographically
&gt; secure hashes. I would like Lyra2 better if it called a full Blake2b
&gt; round now and then to scramble the sponge state.

The funny part is: it kind of does :-) 

The fact that each row has &gt;=12 columns ensures that a full hash is performed for scrambling the internal state (at least the capacity part, which is in the foundation of any sponge's security). The "kind of" is due to the fact that we also read blocks and XOR them into the state, but that is basically the same thing as adding constants to the hashing process, which was one of the operations in Blake itself, but suppressed in Blake2 for better speed (they decided to rely on the IV only). Actually, they are arguably better than constants from a cryptanalysis point of view, since they change with each password, are expected to be random-like (making it hard to explore weak values, for example) and are not controlled/known by the attacker until the algorithm is run (and, by that time, cryptanalysis would be rather useless for password cracking...). 

&gt; In between 6KiB blocks seems like a good place to me. That would give
&gt; me a warm fuzzy feeling about it's security without slowing it
&gt; significantly.

&gt; Lyra2 lacks compute-time hardening and Bcrypt-like GPU defense.
&gt; Blake2b computations can be sped up a great deal in ASIC attacks,
&gt; even if it's better than Keccak. External DRAM memory bandwidth is
&gt; likely only the speed limiting factor, so I recommend Lyra2 be used
&gt; with &gt; 30MiB of memory or more. This works reasonably well against
&gt; ASIC/GPU attacks limited by bandwidth, where maybe attackers have a
&gt; 10X-ish advantage in bandwidth/dollar. That's pretty good defense,
&gt; IMO. However, government-scale attackers may integrate Lyra2 cores
&gt; directly on advanced high capacity DRAM die, greatly reducing the
&gt; bandwidth bottleneck. Also, the 6KiB block size is read
&gt; sequentially, enabling very high speeds on-chip from the densest
&gt; available RAM. Lyra2 has a compile-time option to reduce the block
&gt; size, which can be used to compile a version of Lyra2 more well
&gt; suited for low-memory cache-bound hashing. I would prefer to see
&gt; that as a runtime option.

That can be easily done. In the reference implementation, we did not allow most of the run-time parameterization envisioned in a "real implementation" (1)due to the restrictions of the PHS interface and (2) aiming to take advantage of the compil er's optimization. 

&gt; Also, Lyra2's second loop lacks the small random reads similar to
&gt; what Bcrypt does. This apparently can be used to harden against GPU
&gt; attacks at smaller memory sizes. To me, small memory hashing that
&gt; fits in cache seems rather pathetic for a memory-hard algorithm, so
&gt; requiring Lyra2 to bust into DRAM to get decent GPU defense is fine
&gt; by me.

That is one of the envisioned tweaks mentioned in another e-mail (the \chi parameter, described in section 6.2) . We did not include it in the submission because (1) we did not have time to test its usefulness and (2) this would again be fixed at compilation time due to the reduced number of parameters defined by the PHS interface. But this is certainly in our TODO list! 

&gt; Finally, I'm not a fan of the backwards incrementing addressing
&gt; pattern for the other row to hash in the 1st loop for cache-timing
&gt; resistance. Depending on the XORs to provide defense bothers me
&gt; since there are so many cases where XORs have failed us, even in
&gt; PBKDF2. Gambit, for example, showed very strong TMTO defense against
&gt; my pebbling algorithm at the 1/8th memory mark even without modeling
&gt; Gambit's XORs, so I believe it is TMTO secure. Without the XORs,
&gt; Lyra2's first loop is weak against pebbling attacks, so I need to be
&gt; convinced that the XORs provide the needed defense. Given how XORs
&gt; have let us down before, that's a difficult bar to reach. I would
&gt; recommend doing a bit more than just an XOR, or changing the memory
&gt; access pattern to one that is more secure.

We did try to manually pebble the Setup phase in the document and found it to be very hard at 1/8th memory usage even with this simple approach. The rationale here is that the XORs ensure that values easily computable from the password (e.g., M[0] and M[1]) depend on much more expensive ones (e.g., M[0] depends on every power of two, M[1] on powers of 2 minus 1, etc.). Also, when combined with the Wandering phase, pebbling anything should oblige the attacker to run a large portion of the Setup. If the rows thereby computed have been replaced (an that is one of the goals of the Wandering phase), doing so without raising the memory usage should be far from easy: need row M[0] because you discarded it? Well, it depends on M[4], which you have on memory but, unfortunately, you have modified when computing M[C]. If you have M[C] on memory and it was not modified during the Wandering phase, lucky you. Otherwise, keeping M[4] in memory was not you best move... 

Anyhow, as I mentioned in another e-mail, we are still trying to find the "sweetest spot" that combines simplicity and TMTO resistance using this XORing (or similar) approach. I still have to take a better look at Gambit, but if I understood it correctly, it uses random indices, right? 

&gt; That's all I have for the overall negatives. Most of this can be
&gt; fixed, I think, in the tweak period. Even with the negatives, Lyra2
&gt; is among my favorite algorithms. I saw a number of potential goobers
&gt; in the code. These aren't really negatives, just places the authors
&gt; should double check:

&gt; I think there may be a bug in sse/Sponge.c. If not, at a comment
&gt; explaining how this works is in order. Here's the Blake2b
&gt; implementation:

&gt; static inline void blake2bLyraSSE(__m128i *v){
&gt; __m128i t0, t1;

&gt; ROUND(0);
&gt; ROUND(1);
&gt; ROUND(2);
&gt; ROUND(3);
&gt; ROUND(4);
&gt; ROUND(5);
&gt; ROUND(6);
&gt; ROUND(7);
&gt; ROUND(8);
&gt; ROUND(9);
&gt; ROUND(10);
&gt; ROUND(11);
&gt; }

&gt; Here's the ROUND definition:

&gt; #define ROUND(r) \

&gt; G1(v[0],v[2],v[4],v[6],v[1],v[3],v[5],v[7]); \
&gt; G2(v[0],v[2],v[4],v[6],v[1],v[3],v[5],v[7]); \
&gt; DIAGONALIZE(v[0],v[2],v[4],v[6],v[1],v[3],v[5],v[7]); \
&gt; G1(v[0],v[2],v[4],v[6],v[1],v[3],v[5],v[7]); \
&gt; G2(v[0],v[2],v[4],v[6],v[1],v[3],v[5],v[7]); \
&gt; UNDIAGONALIZE(v[0],v[2],v[4],v[6],v[1],v[3],v[5],v[7]);
&gt; ROUND_LYRA(11);
&gt; }

&gt; Macros can be really weird, but it looks to me like ROUND(r) is not a
&gt; function of r. This might cause the SSE version to have an insecure
&gt; PRK. However, it generates the same hash result as the reference
&gt; version. Is this macro really doing a proper Blake2b round, or is
&gt; this some altered version?

I think this "r" is a legacy from Samuel Neves's implementation. We will take a look. 

&gt; Here's another minor point in the code: Is this legal?

Barely. :-) 

It did work in all our tests with less than ~4GB or RAM, but then it starts to have problems. As I said in another e-mail, we still need to check the code for issues (thank you and Sami Farin for pointing out potential bugs!) 

&gt; __m128i *wholeMatrix = malloc(nRows * rowLenBytes);

&gt; I've seen code like this crash on some platforms. Malloc only
&gt; guarantees 8-byte boundary alignment, and this requires 16-byte
&gt; alignment. Using posix_memalign or similar should fix it.

&gt; There's a minor printf mistake in Main.c, line 214, memory size says
&gt; 'bits', but should be 'bytes'. That's a factor of 8X in speed in 1
&gt; typo!

&gt; Lyra2 allows t_cost == 0, with no wandering phase. This seems a bit
&gt; dangerous...

&gt; On line 192 of non-sse Lyra2.c, why xor state[0] with prev? Since
&gt; state[0] is random, xoring with prev leaves it random but different.

That is a minor tweak that we discuss in section 4.1.2: the idea is to avoid feeding the sponge with "prev XOR prev"( i.e., zeros) when by chance "row* == prev". 

&gt; Both the reference and SSE optimized code only work for little-endian
&gt; architectures. I didn't see that acknowledged anywhere, but I didn't
&gt; read the documentation carefully. There's still work to be done to
&gt; support big-endian machines.

&gt; Bill
<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
