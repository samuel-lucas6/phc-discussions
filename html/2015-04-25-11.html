<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] "Attack on the iterative compression function"</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="10">[&lt;prev]</a> <a href="12">[next&gt;]</a> <a href="../../../2015/04/23/8">[&lt;thread-prev]</a> <a href="../../../2015/04/27/1">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;892601121.51049219.1429985500238.JavaMail.root&#64;larc.usp.br&gt;
Date: Sat, 25 Apr 2015 15:11:40 -0300 (BRT)
From: Marcos Antonio Simplicio Junior &lt;mjunior&#64;...c.usp.br&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] "Attack on the iterative compression function"

----- Mensagem original -----

&gt; De: "Solar Designer" &lt;solar&#64;...nwall.com&gt;
&gt; Para: discussions&#64;...sword-hashing.net
&gt; Enviadas: Quinta-feira, 23 de Abril de 2015 3:39:37
&gt; Assunto: Re: [PHC] "Attack on the iterative compression function"

&gt; On Sun, Apr 19, 2015 at 03:03:33AM -0300, Marcos Antonio Simplicio
&gt; Junior wrote:
&gt; &gt; ----- Mensagem original -----
&gt; &gt; &gt; De: "Solar Designer" &lt;solar&#64;...nwall.com&gt;
&gt; &gt; &gt; On Sat, Apr 18, 2015 at 10:55:54PM -0300, Marcos Antonio
&gt; &gt; &gt; Simplicio
&gt; &gt; &gt; Junior wrote:
&gt; &gt; &gt; &gt; After the initialization, though, the row is always read in the
&gt; &gt; &gt; &gt; same order, so no further latency penalties apply as the
&gt; &gt; &gt; &gt; recomputation depth grows.
&gt; &gt;
&gt; &gt; &gt; Why does this mean no further latency penalties? The
&gt; &gt; &gt; recomputation
&gt; &gt; &gt; algorithm is unlikely to encounter the same missing row again
&gt; &gt; &gt; before the
&gt; &gt; &gt; row has to be thrown out of the algorithm's temporary storage.
&gt; &gt; &gt; And the
&gt; &gt; &gt; row's columns are still needed in reverse order of computation,
&gt; &gt; &gt; so the
&gt; &gt; &gt; first-computed column, which has to be stored, is the last-needed
&gt; &gt; &gt; one.
&gt; &gt; &gt; Am I missing something?
&gt; &gt;
&gt; &gt; I'm not sure we are talking about the same thing, so I decided to
&gt; &gt; draw what I was trying to say (see attached image):
&gt; &gt;
&gt; &gt; 1) If we initialize a row and later read/update it in the same
&gt; &gt; order, then the recomputation of *that row* after several updates
&gt; &gt; takes only C, since the updates can be pipelined
&gt; &gt;
&gt; &gt; 2) If we initialize a row in one order and all subsequent
&gt; &gt; read/updates are done in the reverse order, then the recomputation
&gt; &gt; of *that row* after several updates takes 2C, since the updates
&gt; &gt; can be pipelined among themselves, but not before the row is fully
&gt; &gt; initialized. (note: this is what we are doing with Lyra2)
&gt; &gt;
&gt; &gt; 3) If we initialize a row in one order, and each subsequent
&gt; &gt; read/update is done in the same but the columns are themselves
&gt; &gt; reversed, then there is no easy pipelining (unless, of course, if
&gt; &gt; some extra columns besides the first one are kept in memory to
&gt; &gt; accelerate computations)

&gt; And of course I meant approach (3), where every BlockMix would write
&gt; the
&gt; block in reverse order from reading. (This might be easier
&gt; implemented
&gt; by reading in reverse order and writing in sequential order, since
&gt; we're
&gt; already starting with the last sub-block in (ye)scrypt now. Also,
&gt; keeping the writes in sequential order allows to keep Integerify()
&gt; defined in the same way as it is in scrypt, using the last sub-block.
&gt; OTOH, sequential reads could be friendlier to the hardware
&gt; prefetcher.)

The only issue here would be that you would need an extra buffer, because the memory position from which you read is not the same on which you write (?) 

&gt; Why do you use approach (2) in Lyra2?

Because (1) it appears to be enough for preventing most of the latency reduction (see Sec. 5.1.2.5, "Storing only intermediate sponge states", of Lyra2's documentation, and also the discussion to your next comment) and (2) it avoids extra complexity/overhead on the legitimate machine (not need to reverse anything or use an extra buffer) that might not appear for FPGA-based attacks (as the reversal would just be a matter of rewiring). As a side note, if one does implement reversal as a separate, second operation shown our illustration, the memory bandwidth might be larger in architectures with write-through caches: the write operation would go down the memory hierarchy the first time we write, and also the second. 

&gt; Also, why do you call this attack "pipelining"? While extra
&gt; computation
&gt; parallelism may allow for more efficient use of compute cores,
&gt; including
&gt; by unrolling them and keeping their resulting pipeline stages busy at
&gt; more times, this does not appear to be essential, nor specific to
&gt; this
&gt; one attack. The attack appears to be primarily about parallel
&gt; computation and latency reduction rather than specifically about an
&gt; extra opportunity for pipelining (which might be e.g. a 2x
&gt; performance
&gt; improvement over an iterative implementation of the primitive, which
&gt; would then not have been unrolled not to waste the area). This is a
&gt; reason why scrypt's paper wording about pipelining (and only it) as
&gt; rationale for the sub-block shuffling continues to puzzle me. Am I
&gt; still missing something? Or is this in fact just weird wording,
&gt; focusing on a relatively minor aspect rather than on the major one?

I'm not sure if Colin Percival was thinking the same thing as we, but since I started drawing the attack scenario with pipelining for masking latencies, I expanded the illustrations to include how this could be done for scenarios 1 and 2, assuming (for the sake of giving a concrete example) a 1/3 memory usage and that we need a row after it has been updated twice since initialization. The figures are in the attached pdf file. In summary, to keep the discussion short (and, hopefully, the pictures give a general picture): 

- Strategy (1) allows pipelining both initializations and updates during recomputations, so the latency can be masked quite well in iterative compression functions (slides 2-4) 

- Strategy (2) allows pipelining only the updates, so memory reductions ignoring all dependencies between rows except for the dependence on the previous one should allow up to 2x of the latency to be masked on average, but no useful gain in the worst case (slides 5-7) 

- However, considering dependencies of other rows and also the fact that they are updated along Lyra2's execution, the average scenario should approach the worst case, as the perceived latency would correspond to the maximum latency of all recomputation pipelines involved, and also involve extra latencies not shown in the simplified scenario (slide 8). The higher the memory reduction, the more latency due to initializations; the longer the pipeline (i.e., the more the row is read/updated), the larger the number of dependencies. Hence, even if we ignore hardware limitations (e.g., bandwidth), relying on pipelining for masking the latency of recomputations does not scale very well 

- Strategy (3) does not allow any pipelining, as the updates also need to be sequential, but in Lyra2 they would basically complement the TMTO resistance provided by the measures mentioned in the above point. It may be useful, though, in other schemes (I cannot say whether or not it is the case for yescrypt without further analysis, though) 

I hope this helps! 

Marcos. 

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>

<span style="font-family: times;"><strong>Download attachment "</strong><a href="11/1" rel="nofollow" download>ComputeLatency.pdf</a><strong>" of type "</strong>application/pdf<strong>" (105647 bytes)</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
