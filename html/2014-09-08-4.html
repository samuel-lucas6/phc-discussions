<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] A review per day - Lyra2</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="3">[&lt;prev]</a> <a href="5">[next&gt;]</a> <a href="3">[&lt;thread-prev]</a> <a href="5">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;540DC471.5040102&#64;larc.usp.br&gt;
Date: Mon, 08 Sep 2014 12:00:01 -0300
From: Marcos Simplicio &lt;mjunior&#64;...c.usp.br&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] A review per day - Lyra2



On 06-Sep-14 11:44, Bill Cox wrote:
&gt; Summary
&gt; --------
&gt; 
&gt; I'm taking this review as my chance to compare the three best Scrypt
&gt; replacement algorithms.  See the attached spreadsheet for a quick
&gt; summary of this comparison.  I give a 100 to the best algorithm in
&gt; each category, and try to rate the merit on a scale from 0 to 100 on
&gt; the rest.  Some other candidates would achieve a higher rating than
&gt; these algorithms in some categories.  A lot of this is a matter of
&gt; opinion, especially the relative scores which are in fuzzy units.
&gt; 
&gt; Lyra2 is one of three serious entries that succeeds at improving over
&gt; Scrypt.  There are some other entries that try, but fall short when
&gt; hashing 1GiB rather than 1MiB.  A couple do a great job, such as
&gt; EARWORM, but are not general purpose like Scrypt.
&gt; 
&gt; The three serious potential Scrypt upgrades are Lyra2, TwoCats (my
&gt; entry), and Yescrypt. IMO, any presentation contrasting the PHC
&gt; entries that does not include at least one of these algorithms in
&gt; their "winners" picks shows that the presenter does not understand the
&gt; relative merits of the entries.

I think you went a little overboard here, since there have been (and
probably there will be more) comparisons which do not include some of
the algorithms, depending on what one wants to analyze. But since you
included Lyra2 in the pack, I will not complain further. :)

&gt; 
&gt; While Lyra2 is an excellent entry, and a worthy upgrade to Scrypt, I
&gt; prefer TwoCats over Lyra2, and Yescrypt over TwoCats.  I'll spend most
&gt; of this long review contrasting these three algorithms.  It is not
&gt; possible for me to do this in an unbiased way, and I apologize to the
&gt; Lyra2 authors for this.  Please do chime in and correct me, and add
&gt; additional comparison criteria.

I will try to be objective too, but no assurances there...

&gt; 
&gt; Basically, to be a decent upgrade to Scrypt, you need:
&gt; 
&gt; - A GPU defense strategy
&gt; - An ASIC defense strategy
&gt; - A fast hashing algorithm for filling memory - NOT a full
&gt; cryptographic hash
&gt; - A method for lowering DRAM cache-miss penalties
&gt; - A Time-Memory Trade-off (TMTO) defense strategy
&gt; - Multi-threading support with data exchanges between threads
&gt; - Carefully tuned hashing optimized for SIMD
&gt; - Low dependence on special hardware
&gt; 
&gt; Comparison
&gt; ----------
&gt; 
&gt; Yescrypt wins at GPU defense, due to it's rapid unpredictable small
&gt; memory reads from L1 cache.  Like bcrypt, Yescrypt issues multiple
&gt; unpredictable small memory reads in parallel, to get to about 1/2 the
&gt; number that bcrypt does when single-threaded.  TwoCats only issues one
&gt; unpredictable read at a time, and performs them at about 1/3 the
&gt; number as bcrypt when single threaded.  However, Yescrypt is designed
&gt; to max out everything at the same time, including CPU cores, while
&gt; TwoCats runs into memory bottlenecks on my test machine using only
&gt; half the CPU cores.  This gives Yescrypt a 3X-ish advantage over
&gt; TwoCats in unpredictable read rate, which likely translates into
&gt; better GPU defense.  Lyra2 does small-ish unpredictable reads, but
&gt; only once per Blake2b reduced round, which is several clock cycles,
&gt; and several times slower than either Yescrypt or TwoCats.  This
&gt; translates into weaker GPU defense, though I am not qualified to say
&gt; by how much.

Did you actually benchmarked all three algorithms on a GPU? Because we
did so with Lyra2 and, even without the additional small random reads
prescribed in section 6.2, the performance on our GPU was ~200 times
worse than in our CPU (we testes for memory usages between 96 MB and 800
MB). That was the main reason why we did not include this extension in
the core of Lyra2, but left it there for further analysis in a more
powerful GPU.

Even if TwoCats and Yescrypt (and Lyra2 with the above extension)
provide a 1000x slow down on GPUs, what is the point? If it is much
slower, that will probably be enough to make GPUs out of the list of
preferred attack platforms... Well, that unless the attacker can use a
TMTO attack to bring down the memory usage to a level that fits a GPU
and then use its multiple cores more efficiently, and that is why we
focused on TMTO in our design.

&gt; 
&gt; ASIC defense for large memory hashing is excellent for all three,
&gt; assuming Lyra2 becomes multi-threaded.  An ASIC attacker will quickly
&gt; become memory bandwidth limited.  Practical ASIC attacks have at most
&gt; about a 32 times higher memory bandwidth than a modern high-end CPU.
&gt; This enables an attacker to run up to 32 times faster, but the expense
&gt; per ASIC of such a system is likely similar to the cost of a desktop
&gt; PC.  TwoCats and Yescrypt have multiplication chain compute-time
&gt; hardening, which in some cases will limit an attacker's ability to
&gt; hash at the full speed supported by his memory bandwidth.  In that
&gt; case, Yescrypt and TwoCats will force an attacker to either make fewer
&gt; guesses per second, or buy more memory so that more attacks can be
&gt; interleaved, filling up memory bandwidth.  Yescrypt and TwoCats win
&gt; over Lyra2 because of this.  TwoCat's multiplication chains are
&gt; tunable, allowing it to tune the multiplication chain lengths to the
&gt; hashing speed of the machine.  This allows TwoCats to be more
&gt; multiplication chain hardened than Yescrypt in some cases.  The extra
&gt; area on the ASIC needed by Lyra2 and Yescrypt computation logic vs
&gt; TwoCats is tiny, as there would only be 32 copies at most.  TwoCats
&gt; has a slight win here over Yescrypt.

Multiplication hardening does seem to be an interesting thing, and that
I see as one of the main contributions of Yescrypt and TwoCats. We are
still looking for something like that to suggest as part of the sponge's
underlying "f" permutation, but I agree you and Alexander have the lead
on the matter.

OTOH, I would like to see an analysis of the strength of the proposed
algorithms in terms of confusion and diffusion capabilities. For
example, taking the multiplication chain of TwoCats, the "a ^= b*c &gt;&gt;
32" operation is more likely to provide 0s than 1s to be XORed with a.
Is that critical in terms of security? Maybe not, but without any
security claims about what that multiplication chain should achieve and
why, it is hard to tell.

Just to be clear: no FUD meant here! My point is that, as someone
mentioned in another thread (I could not find who), it is standard in
the cryptography community to analyze your own design and make security
claims about it so other people can (1) check the design against those
claims and (2) agree/disagree about whether these properties are enough.

&gt; 
&gt; Against 1-8MiB on-chip memory hashing ASIC attacks, Yescrypt and Lyra2
&gt; make increased use of the SIMD unit which will cause the AISC to be
&gt; slightly bigger than when attacking TwoCats.  All three algorithms
&gt; will max out the large memory access speed, but Yescrypt does two
&gt; unpredictable reads in parallel, which should slow down the ASIC
&gt; memory slightly.  On the other hand, multiplication chains might into
&gt; play here.  The ASIC memory can be optimized for the algorithm in use,
&gt; allowing much lower average latencies, and the right number of
&gt; read/write ports.  Only the multiplication chains will keep an
&gt; attacker from making full use of his improved memory speed.  I think
&gt; Yescrypt and TwoCats tie here because TwoCat's better multiplication
&gt; hardening and Yescrypt's slightly larger area may cause roughly equal
&gt; grief to the attack.
&gt; 
&gt; TwoCats and Yescrypt fair better than Lyra2 against and ASIC attack
&gt; when hashing only 8KiB of memory.  With multiplication chains, an ASIC
&gt; attack might still speed up TwoCats by 2X, and Yescrypt maybe 3X (a
&gt; bit of a WAG here).  However the Blake2b hash was practically designed
&gt; for an ASIC attack, and will run many times faster.  The lack of
&gt; compute time hardening in Lyra2 will allow maybe a 10X speed increase
&gt; for the attacker.  The area of the multipliers in TwoCats and Yescrypt
&gt; also become a factor, being around the same size as the memory in
&gt; Yescrypt's case, and about half that in TwoCat's case.  Because of the
&gt; extra area required for Yescrypt hashing, I cannot predict which has
&gt; the better ASIC defense.  I would call it a tie again between Yescrypt
&gt; and TwoCats, with Lyra2 trailing by some distance.

If you consider Blake2b as the underlying permutation, than I cannot
disagree. And that is why we are analyzing other possibilities for our
(reduced-round) permutation.

&gt; 
&gt; It may be common for some groups of users to run single-threaded,
&gt; though I recommend against it in all cases except for single-core
&gt; CPUs.  In that case, TwoCats wins in ASIC defense simply because it
&gt; will fill more memory than either Lyra2 or Yescrypt.  A single TwoCats
&gt; thread fills external memory over twice the speed of either Yescrypt
&gt; or Lyra2.  When no SIMD unit is available, that ratio might increases
&gt; by a factor of about 4, corresponding to the pipeline depth used in
&gt; the SIMD units by Yescrypt and Lyra2.

Just to be clear: those benchmarks were made with Lyra2, TwoCats and
Yescrypt with the minimal parameters? I ask because the minimum
recommended value in Lyra2 is T=1 (i.e., R iterations of the Wandering
phase), while TwoCats and Yescrypt seem to propose something equivalent
to "T=1/3" as minimum parameter (i.e., R/3 iterations of the Wandering
phase).

Without some kind of normalization (e.g., executing only 1/3 of Lyra2's
Wandering phase or using a higher T for TwoCats and Yescrypt, if we are
analyzing only hashing speed), these comparisons do not sound very fair.

Anyhow, to be really fair Lyra2 would also have to provide a parallel
implementation, which is almost done and should be publicly released
soon. I do not doubt TwoCats and/or Yescrypt will be faster, but

&gt; 
&gt; By the way, TwoCats and Yescrypt also beat bcrypt in tiny memory ASIC
&gt; attacks.  Bcrypt may make 4 parallel unpredictable reads per cycle,
&gt; but it does so to 4 separate super-tiny SRAMs, making them even
&gt; faster, and it has zero compute-time hardening.
&gt; 
&gt; For defense against cache-timing attacks, TwoCats wins.  A
&gt; cache-timing upgrade is planned for Yescrypt, and Yescrypt may come
&gt; out on top when this happens, but without an algorithm to test, it is
&gt; impossible to say.  Lyra2 has a cache-timing resistant first loop,
&gt; like TwoCats, but it uses a weak memory access pattern that leaves it
&gt; vulnerable to a very high TMTO attack when cache-timing data is
&gt; available.  Lyra2, IMO, should be upgraded to use something like the
&gt; Gambit memory access pattern, which defended against my auto-pebbler
&gt; attack far better.

I can't argue with that either: as I said the first time you mentioned
this issue, we were experimenting with different pebbling strategies
trying to find something both simple and strong, especially after our
tests with bit-reversal failed. We did find a better approach (which
also facilitates analysis!) which combines "simple reverse" and
"variable step". The approach itself is described in the documentation
available at <a href="http://lyra-kdf.net/" rel="nofollow">http://lyra-kdf.net/</a>, but the security analysis is not
there yet (it will be as soon as I handle the LaTeX warnings and errors
in the document...)

&gt; 
&gt; One of the most important applications for a password hashing
&gt; algorithm of the strength that can be provided by these algorithms is
&gt; user authentication on dedicated authentication servers.  Yescrypt
&gt; clearly wins in this category, and in fact the algorithm seems to have
&gt; been designed with this application as the primary target.  The extra
&gt; security provided to small memory hashes of a few MiB with large ROM
&gt; hashing puts it in a class only shared by EARWORM.  EARWORM was my
&gt; other favorite for this category until I realized it has a weakness
&gt; against distributed ROM attacks due to it's very low RAM usage.  As
&gt; things stand, Yescrypt is easily the best algorithm for authentication
&gt; servers in the competition.  It's weaknesses, such as not yet having
&gt; any cache-timing defense, don't matter much in this application, and
&gt; it's strengths really come to bear.  Yescrypt will keep 8 CPUs very
&gt; busy in parallel while hammering memory at insane speeds, providing
&gt; thousands of authentications per second, strengthened by ROM hashing
&gt; in addition to megabytes of memory.  Even if the password database AND
&gt; ROM leak to an attacker, a botnet will not be able to work on password
&gt; cracking if the ROM is large enough.  There are many features besides
&gt; this in Yescrypt for authentication servers.  In comparison, both
&gt; TwoCats and Lyra2 opted for a bit more simplicity, and provide no
&gt; authentication server specific features, such as ROM support.

I have to agree that Yescrypt's ROM idea against botnets is very clever
and that its cache-oriented design is ingenious. It may be on the best
interest of all PHC candidates to at least consider including ROM
support to their designs, which I believe will not be very difficult for
most (if not all) entries. Making better use of caching, on the other
hand, will require someone with expertise on computers architecture...


&gt; 
&gt; While all three have no requirement for special hardware, all three
&gt; are tuned for modern x86 SIMD units.  TwoCats I think wins in
&gt; adaptability to basic CPUs.  This is because it can run with a single
&gt; 32-bit width with far fewer instructions per byte of memory hashed.
&gt; Yescrypt also has variable width SIMD loops, but it's pipeline depth
&gt; is not currently variable, making it slow down somewhat on a basic
&gt; CPU.  TwoCats wins here because it uses less pipelined parallelism.
&gt; This is basically a duplicate of the single-threaded comments above :-)

Well, that depends on what you adopt as underlying "f" in Lyra2 :)

&gt; 
&gt; All three algorithms have variable hashing block sizes, enabling them
&gt; to tune to a machine's DRAM cache miss penalty.  The longer the
&gt; penalty, the more memory you want to read in one shot.  All three tie
&gt; on this point, but win vs most of the other entries.  Every entry
&gt; without a capability to read large blocks of memory at a time cannot
&gt; supplant Scrypt.

Just one remark here: the original idea of doing so came from scrypt itself.

&gt; 
&gt; Lyra2 easily wins at TMTO defense.  Both Lyra2 and Yescrypt use
&gt; increasing t_cost to improve TMTO defense, but Lyra2's decision to
&gt; continue overwriting memory while reading I think makes it more TMTO
&gt; resistant.  TwoCats as submitted uses t_cost poorly.  A revised
&gt; version exists that will be submitted if allowed, which does increase
&gt; TMTO resistance as t_cost increases, but this feature works better in
&gt; Lyra2 and Yescrypt.  However, because TwoCats was designed as a single
&gt; pass algorithm, it has the best TMTO resistance when t_cost turned
&gt; off, meaning only one memory pass.  This is not a mode Lyra2 allows,
&gt; but Yescrypt does, and both Yescrypt and TwoCats achieve higher
&gt; memory*time defense as a result.

I'm not sure I understood what you mean, but it seems to be a matter of
including an "if" in the code...

&gt; 
&gt; All three have a TMTO defense that improves over Scrypt, but Lyra2
&gt; sacrifices speed and thus time*memory defense in order to improve it's
&gt; TMTO defense.  This lower time*memory defense may be the main reason I
&gt; prefer TwoCats and Yescrypt.  TMTO attacks gain little against TwoCats
&gt; in any configuration (maybe 10-15% time*memory benefit), and even less
&gt; against Yescryt and Lyra2.  This is why I feel TMTO defense is not a
&gt; very important factor when comparing these three algorithms.  If TMTO
&gt; defense were paramount, I would choose Lyra2 as my favorite.  As it
&gt; is, TMTO defense is good enough in all three.  A final note about
&gt; TMTO: Yescryt and TwoCats both have techniques for mixing data between
&gt; threads, making it difficult to benefit from running each thread
&gt; sequentially.

I'm not so sure about the importance of TMTO resistance in a design,
especially considering that most of scrypt's article is focused exactly
on this issue...

Anyhow, the main interest of Lyra2 over the original Lyra is exactly the
TMTO resistance, while the extension discussed in section 6.3 does
suggest that this TMTO resistance in terms of number of reads/writes
could be parameterized. That is something we have been playing with
lately, although it seems that lowering the number of reads/writes
(i.e., making something similar to Lyra) makes sense only in a
multi-thread scenario, in which the multiple threads can compensate as
suggested by the analysis in section 6.1.

BTW, the parallel version suggested in Lyra2 does mix data between threads.



&gt; 
&gt; As for time*memory defense, Yescrypt, when run with t_cost == 0, has
&gt; the same characteristics as TwoCats, filling memory linearly, never
&gt; stopping until enough memory has been hashed.  This maximizes
&gt; time*memory defense vs any other possible solution.  Lyra2 does at
&gt; least two passes over memory, doing twice as many read/write
&gt; operations per memory location.  This causes it to use half the memory
&gt; as TwoCats and Yescrypt when memory bandwidth limited.  All of my ASIC
&gt; attack plans so far would need only half the memory to attack Lyra2
&gt; hashes, lowering it's time*memory defense by 2X.  However, a more
&gt; sophisticated attack might be able to take advantage of the unfilled
&gt; memory until it is needed, lowering the time*memory penalty to only a
&gt; 3/4ths of TwoCats and Yescrypt.

See above

&gt; 
&gt; For pure memory hashing speed per thread, TwoCats is the fastest,
&gt; followed by Lyra2, and then Yescrypt.  However, this is a deliberate
&gt; design choice by Alexander, and not significant weakness in Yescrypt,
&gt; as he demonstrated by slightly tweaking Yescrypt to be virtually as
&gt; fast per thread as TwoCats during a benchmarking fest.  The idea is
&gt; that the best defense occurs when all parts of the CPU and memory are
&gt; in use at the same time.  Yescrypt maxes out memory bandwidth at about
&gt; a CPU's full parallelism, which is when all cores are used to hash at
&gt; the same time.  TwoCats maxes out memory bandwidth with about 1/4 as
&gt; many threads, and cannot employ all CPU cores at the same time like
&gt; Yescrypt does.  The decision to max out CPUs vs trying to do the most
&gt; possible with one thread is based on the importance of different
&gt; scenarios.  For a low-powered single core processor, TwoCats will do
&gt; better than either Yescrypt or Lyra2, because multiple threads will
&gt; not help in that situation.  For high-end authentication servers
&gt; protecting passwords for major corporations, Yescrypt wins by
&gt; providing better computational hardness - an attacker will need many
&gt; SIMD unit's worth of processing power to run as fast as the
&gt; authentication server.  Once Lyra2 is upgraded with multi-threading,
&gt; it should do better than TwoCats, but worse than Yescrypt at
&gt; computational hardness (which is different than runtime hardness).
&gt; IMO, computational hardness matters little, since even multipliers are
&gt; tiny on an advanced ASIC.  Memory really is all that counts in terms
&gt; of silicon expense.

Our benchmarks with a parallel version do show that it is hard to beat
Yescrypt's internal function in terms of cache usage. If the security of
the algorithm proves to be strong, I have to give thumbs up for Yescrypt
on this matter.

&gt; 
&gt; As for basic security, Yescrypt and TwoCats run well accepted
&gt; cryptographic hash functions on all inputs at the beginning to create
&gt; a derived key, and that key is hashed with the result of memory
&gt; hashing again with the cryptographic hash function at the end.
&gt; Regardless of any weakness in TwoCats or Yescrypt memory hashing, this
&gt; scheme will preserve entropy and will always hash at least as securely
&gt; as two applications of the cryptographic hash. 

I agree with the phrase, but that basically implies that it may also be
just as strong as those two applications of the cryptographic hash...

This is actually my main concern with TwoCats and Yescrypt: so far, I
have seen no analysis that shows that "there is no loss of entropy" in
the internal process. The fear that this may not be the case seems to be
among the reasons why many entries, some of them created by people
experienced in the area of security, prefer to use a full hash in the
algorithm's design. This conservative approach at least gives them a
security margin that allows them to build security claims more easily.
Again, no FUD intended here: what I would like to see are exactly those
security claims...


&gt; Lyra2 relies on the
&gt; reduced Blake2b function's application over and over many times while
&gt; hashing to cryptographically scramble it's sponge's state, and it
&gt; relies on this slightly modified Blake2b function to not lose entropy.
&gt;  The final output is squeezed from the sponge.  Because of this
&gt; construction, Lyra2 hashing security needs careful analysis by hashing
&gt; experts to verify it has no significant weakness.  I personally do not
&gt; feel qualified to do it.  However, I do believe that they most likely
&gt; got it right.  However, I would say TwoCats and Yescrypt win here, in
&gt; being trivial to prove basically secure.

I believe the exact opposite: it is non-trivial to say whether or not
everything made between the two calls of the hash function in TwoCats
and Yescrypt is secure or not. Remember your criticism about Schvrch,
for example: at first sight, and without reading the analysis in the
mentioned paper, it is hard to say whether or not the evolve and revolve
functions would actually prevent shortcuts in the computation. Why is it
"trivial" for a multiplication chain?

In Lyra2, we are semi-conservative: we combine a sponge construction,
for which there many analysis stating that it may be used as long as the
underlying "f" is a good permutation, and a function whose analysis
indicate that it is a good permutation (originally, Blake2b, but it
could be anything else). When we take the reduced round "f", we are
actually relying on the fact that, in the long run (i.e., after a few
rounds), this reduced-round operation becomes as secure as the
full-round version, as prescribed by the ALRED construction. The first
and last operations are done with the full sponge (again, following
ALRED), so the whole design should be at least as secure as "2+R \times
(rounds/rounds_max)" applications of the hash function.



&gt; 
&gt; TwoCats and Yescrypt win vs Lyra2 in terms of being ready for
&gt; deployment.  Lyra2 still uses memset to clear buffers, just as a
&gt; placeholder for the real function, and has no byte swapping to deal
&gt; with big-endian machines.  There is no provision for locking memory
&gt; from swap (mmap vs malloc).  It also still needs a thread upgrade,
&gt; while TwoCats and Yescrypt are in theory ready, other than needing
&gt; more review, for deployment now.  There are planned upgrades to
&gt; Yescrypt, but nothing critical, while TwoCats has a modified t_cost
&gt; loop that has not yet been submitted.  Lyra2 does not yet have a
&gt; parameter estimation function, while Yescrypt and TwoCats do.  In
&gt; reality, simply because Alexander makes so few mistakes, Yescrypt is
&gt; the closest entry of the three to being ready for deployment, edging
&gt; out a close win here vs TwoCats.

I cannot argue with that either, except maybe to say that we would
probably have a different AES today if the reference implementation was
all that counted in that contest :)

&gt; 
&gt; Of the three, Lyra2 has the simplest and most elegant design.  The
&gt; sponge construction was a pleasure to read, and cleverly done.
&gt; TwoCats probably comes in second here, simply because it inherits no
&gt; baggage from Scrypt, but complexity is a significant weakness of the
&gt; full TwoCats algorithm, which is why I also wrote the very simple
&gt; SinnyCat subset algorithm.  Starting with the complexity of Scrypt and
&gt; building on it made Yescrypt more complex than Lyra2 or TwoCats.  I
&gt; consider this to be the most significant weakness of Yescrypt, and the
&gt; most significant advantage of Lyra2.

While simplicity was indeed a goal in the design, probably that
impression comes from the fact that we tried to make a core and leave
extensions out of it. If you put everything suggested as "extension" on
the same (pseudo)code, things get much more complicated. I believe the
inverse is also valid for Yescrypt and TwoCats: take out the "ifs" and
you get a simpler design (well, that ignoring the internal hash
functions, which are more complex to understand and analyze...).

&gt; 
&gt; Of the three, only TwoCats has a pluggable hash function, meaning that
&gt; it can easily run with different secure cryptographic hashes.  The
&gt; default is Blake2b for it's speed, but TwoCats comes with SHA256 and
&gt; SHA512 enabled as well.  This is only a minor weakness in Yescrypt,
&gt; because there is nothing in Yescrypt preventing this feature from
&gt; being added.  However, in Lyra2 it is fairly difficult to change the
&gt; underlying hash function.  Any change means that the algorithm needs
&gt; to be reviewed again carefully for any cryptographic weakness by
&gt; experts.  In contrast, any C programmer will find it trivial to change
&gt; the hash in TwoCats.

Hum... that is a good point, but only if you take "reduced-round hash
function" literally (and that was our intention!). However, if you can
find any good permutation to use in the middle of the algorithm (i.e.,
the "reduced-round function" that can be proven to be secure in the long
run, then I do not see any reason why the first absorb and the last
squeeze can be done with another permutation. Nonetheless, I would not
put the security of a system on something that may or may not be secure...

&gt; 
&gt; Yescrypt wins in another imporant category: ease of adoption.  While
&gt; remaining compatible with Scrypt has made Yescrypt more complex than
&gt; needed, it also makes it easier to deploy.  Anyone out there with
&gt; Scrypt already can simply replace it with Escrypt, and enjoy the
&gt; benefit of the higher speed in Alexander's implementation.  They can
&gt; easily switch to stronger hashing techniques provided in Yescrypt at
&gt; any time.  In contrast, users will have to learn about a whole new
&gt; hashing scheme to adopt TwoCats or Lyra2.

Agreed.

&gt; 
&gt; Bill
&gt; 


<span style="font-family: times;"><strong>Download attachment "</strong><a href="4/1" rel="nofollow" download>signature.asc</a><strong>" of type "</strong>application/pgp-signature<strong>" (664 bytes)</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
