<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: Second factor (was A review per day - Schvrch)</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="21">[&lt;prev]</a> <a href="23">[next&gt;]</a> <a href="19">[&lt;thread-prev]</a> <a href="23">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;lu7qak$16b$1&#64;ger.gmane.org&gt;
Date: Wed, 03 Sep 2014 12:31:30 -0700
From: Alex Elsayed &lt;eternaleye&#64;...il.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: Second factor (was A review per day - Schvrch)

Andy Lutomirski wrote:

&gt; On Sep 3, 2014 3:44 AM, "Bill Cox"
&gt; &lt;waywardgeek&#64;...hershed.org&gt; wrote:
&gt;&gt;
&gt;&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt;&gt; Hash: SHA1
&gt;&gt;
&gt;&gt; On 09/03/2014 02:41 AM, Krisztián Pintér wrote:
&gt;&gt; &gt;
&gt;&gt; &gt; Bill Cox (at Wednesday, September 3, 2014, 3:33:27 AM):
&gt;&gt; &gt;
&gt;&gt; &gt;&gt; Is this why you included a ROM in Gambit?
&gt;&gt; &gt;
&gt;&gt; &gt; no, i wanted a second factor in the auth scheme, namely the "have",
&gt;&gt; &gt; and i wanted it to be relatively hard to steal. not that i achieved
&gt;&gt; &gt; this goal, because stealing a ~100MB file is not particularly
&gt;&gt; &gt; difficult these days. not much more difficult than stealing a 32
&gt;&gt; &gt; byte file.
&gt;&gt; &gt;
&gt;&gt;
&gt;&gt; Second factor is something that I think a lot of entries with a secret
&gt;&gt; key or local parameter or data field.  I don't think it has to be
&gt;&gt; integrated in the memory hashing part unless we're trying to build a
&gt;&gt; Yescrypt or EARWORM style authentication server, though it is best if
&gt;&gt; the user isn't expected to hash the ROM himself.  TrueCrypt has a
&gt;&gt; minor weakness in that they use CRC32 hashes for key files rather than
&gt;&gt; a real hash, enabling files to be tweaked such that they don't impact
&gt;&gt; the hash result.
&gt;&gt;
&gt;&gt; There is a second factor hack for TrueCrypt using a bootable USB
&gt;&gt; stick.  The cool part is you no longer need a master boot record or
&gt;&gt; volume header on the encrypted hard-disk, which is basically a little
&gt;&gt; header saying, "I am a TrueCrypt Drive and here are the salt and
&gt;&gt; password hash you need to brute-force attack me.  I'm bending over for
&gt;&gt; you."
&gt;&gt;
&gt;&gt; The hard part about second factor is protecting it, IMO.  I have a
&gt;&gt; GnuPG smartcard now in my pocket, which may mean that my secret
&gt;&gt; signing key is harder to steal than before.  Without such a device,
&gt;&gt; how can users keep any random infected machine they plug it into from
&gt;&gt; hacking them?
&gt;&gt;
&gt;&gt; Even with such a device, how can I know that malware isn't signing
&gt;&gt; random things left and right while I have it plugged in?  It could
&gt;&gt; locate my encrypted BitCoin wallet, and just sit there for years
&gt;&gt; waiting for me to plug in my USB key.
&gt;&gt;
&gt;&gt; A dumb problem with existing second factor schemes where you have a
&gt;&gt; security token is that they seem to simply share a secret with the
&gt;&gt; server.  I see popular security companies like Forticlient have lame
&gt;&gt; processes going on at the protocol level, meaning if the client
&gt;&gt; doesn't see it, they feel no need to make it very secure.  For second
&gt;&gt; factor, they first tell you your token guess is wrong before asking
&gt;&gt; for the password, and they do nothing to protect a password once it's
&gt;&gt; typed in.  My point is we *can't* trust these closed-source companies
&gt;&gt; to protect the shared secret in a way that makes it hard for an
&gt;&gt; attacker to gain both the password and security token databases.
&gt;&gt;
&gt;&gt; In other words, the security token you get from work may be quite lame
&gt;&gt; as defense against brute-force offline attacks.
&gt;&gt;
&gt;&gt; Getting second factor right is hard!  Anyone have any really good
&gt;&gt; non-patented ideas?
&gt; 
&gt; [mostly off topic]
&gt; 
&gt; Yes, sort of, I think.
&gt; 
&gt; Ideally, I want a security token with a few properties:
&gt; 
&gt; a) Use of the token is protected by a passphrase.
&gt; 
&gt; b) The token can't tell whether a given passphrase is correct or not.
&gt; 
&gt; c) If the token is honest, then no one can test a candidate passphrase
&gt; without querying the token once per passphrase tested.
&gt; 
&gt; d) If the token is stolen but the computer it's in remains
&gt; uncompromised, then the token is completely useless to an attacker.
&gt; 
&gt; A naive ECC-based protocol that attempts to have these properties
&gt; works like this:
&gt; 
&gt; Choose a secure elliptic curve E with order r.  Choose an encryption
&gt; function E_k which acts like an ideal cipher mod r (there are standard
&gt; constructions for these things, although modular addition or possibly
&gt; multiplication might actually be good enough for this use case).
&gt; 
&gt; The token has a secret symmetric key K_master.  An actual client
&gt; credential is a scalar S = S_c + S_t.  S_c is the computer's share of
&gt; the scalar and S_t is the token's share.  A server's verifier for a
&gt; client credential is g^S.
&gt; 
&gt; The token stores none of the credential at all.  The client user knows
&gt; a passphrase.  The client's computer stores a salt, and it can compute
&gt; derive kc and kt by some suitable algorithm (presumably using a PHC
&gt; winner!) on the passphrase and the salt.  The client stores E_kc(S_c)
&gt; and E_kt(E_K_master(S_t)).
&gt; 
&gt; The token is willing to take some input mod r, decrypt it using
&gt; K_master, and multiple an EC point by the result.  When the client uer
&gt; enters a passphrase, the computer can obtain S_c and E_K_master(S_t)
&gt; and use the token along with its knowledge of S_c to multiply things
&gt; by S.  It uses this to participate in a zero-knowledge proof of
&gt; knowledge with the server to prove knowledge of S such that g^S
&gt; matches the verifier.
&gt; 
&gt; Why is this good?
&gt; 
&gt; The token doesn't store any credential at all, so stealing it by
&gt; itself is mostly worthless (U2F is like this, too, as is a TPM,
&gt; although stealing a TPM without also stealing the computer it's in
&gt; would be a rather strange attack).
&gt; 
&gt; The client computer and the token, even colluding, can't test a
&gt; passphrase without knowing the verifier.  As far as they're concerned,
&gt; any trial passphrase generates some S value, but the correct S is a
&gt; uniform random number mod r, so correct and incorrect S values are
&gt; indistinguishable.
&gt; 
&gt; If a secure ZK proof is used (see PAKE schemes for examples of how to
&gt; do this), the client and token, even colluding, can only test one
&gt; passphrase value at a time.
&gt; 
&gt; One tricky thing, though: you'd want to carefully encrypt the client
&gt; &lt;-&gt; token communication.  Otherwise someone could potentially sniff it
&gt; and learn something that could be used to test passphrases if they
&gt; watch the communication during a successful authentication.
&gt; 
&gt; NB: In practice, you'd need to be very careful if you use this in a
&gt; protocol with a group of composite order.  I think that the simplest
&gt; approach would be to have the token multiply by the cofactor times its
&gt; share instead of just multiplying by its share.

...this sounds to me like far more complexity than is needed.

If you have the token act as the server for an augmented PAKE, and the 
PAKE's "failed authentication" mode is "return different keys to each 
party", eliding the check step and blindly using the (potentially incorrect) 
derived key as an input to the password scrambler gives the full benefits.

Because a sane PAKE (like SRP, or AugPAKE, or...) yields no information 
about the password to either passive listeners or incorrect guesses, the 
"encrypt the client &lt;-&gt; token communication" bit is irrelevant.

</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
