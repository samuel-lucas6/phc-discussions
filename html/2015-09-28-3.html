<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] Specification of a modular crypt format (2)</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="2">[&lt;prev]</a> <a href="4">[next&gt;]</a> <a href="1">[&lt;thread-prev]</a> <a href="4">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CAGiyFdfn8z=wSuT1VqgHJ-kR9S9cWnE+54xoCqhLXsgE2oAPRA&#64;mail.gmail.com&gt;
Date: Mon, 28 Sep 2015 13:23:59 +0000
From: Jean-Philippe Aumasson &lt;jeanphilippe.aumasson&#64;...il.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] Specification of a modular crypt format (2)

Thanks!

Copied the draft to
<a href="https://docs.google.com/document/d/1QJva4xsY3eHNm2YiT0yPS9spRqd-N8NamYRpF5lkIzM/edit?usp=sharing" rel="nofollow">https://docs.google.com/document/d/1QJva4xsY3eHNm2YiT0yPS9spRqd-N8NamYRpF5lkIzM/edit?usp=sharing</a>

Fixing typos:

"  -- The first character is either a '-' sign, or an ASCII digits"
to
"  -- The first character is either a '-' sign, or an ASCII digit"

"     ** p       Degree of parallelism, between 1 and 255.
                Value is an integer in decimal, over 1 or 2 digits."
to
"     ** p       Degree of parallelism, between 1 and 255.
                Value is an integer in decimal, over 1 or 3 digits."

Other comments:

"with a strcmp() call": should we expect all strings to be null-terminated?

add "The identifier for Argon2ds is 'argon2ds'"?



On Mon, Sep 28, 2015 at 1:13 PM Thomas Pornin &lt;pornin&#64;...et.org&gt; wrote:

&gt; Hello all,
&gt;
&gt; here are my revised specification for the modular crypt format, and
&gt; example code. Here are the changes since the last version:
&gt;
&gt; ** While producers must still follow the unique, deterministic encoding,
&gt;    consumers are officially allowed not to verify that the string is
&gt;    correct. This makes decoding simpler (e.g. no need to check for extra
&gt;    leading zeros in decimal integers) but increases the risk of
&gt;    dissemination of local variants. This also has some consequences
&gt;    which are worth mentioning in the Unix crypt() API; I have added a
&gt;    section about it.
&gt;
&gt; ** I switched back to "normal" Base64, albeit without the '=' padding
&gt;    signs. For C implementations, the choice between standard Base64, and
&gt;    the crypt() variant, should be neutral since the standard library does
&gt;    not offer any implementation of either; in any case, it is easily
&gt;    reimplemented, as the example code demonstrates. For other languages
&gt;    (e.g. C# or PHP), using standard Base64 may allow reusing the
&gt;    facilities of the language framework.
&gt;
&gt;    I still mandate suppression of the '=' padding signs, because
&gt;    otherwise they may make some encodings ambiguous in the presence of
&gt;    optional parameters. For most languages, removing the '=' signs upon
&gt;    encoding is a simple one-liner (e.g. '.Replace("=", "")' in C#).
&gt;
&gt; ** Functions are now supposed to specify the expected order of parameters
&gt;    instead of following a single, universal rule. (It turned out that
&gt;    nobody likes lexicographic ordering.)
&gt;
&gt; ** Parameters can be optional. The function specification must tell which
&gt;    parameters are optional and which are not; for optional parameters,
&gt;    they MUST specify the default value, and an optional parameter MUST
&gt;    be omitted if its value is equal to the default.
&gt;
&gt;    These rules preserve determinism while allowing optional features
&gt;    without overly increasing the hash string length. In Argon2i, I
&gt;    define the m, t and p parameters to be mandatory, and the keyid and
&gt;    data parameters to be optional.
&gt;
&gt; ** Output length can vary. The function must define a default length, to
&gt;    be used unless a very good reason not to do so applies. A sane
&gt;    minimum is still enforced. The output length is NOT made a parameter
&gt;    since this would be redundant with the output itself, and also
&gt;    because it really should not be parameterized in normal conditions.
&gt;
&gt; ** The parameters for Argon2i have been expanded with the keyid
&gt;    (identifier for the key, optional) and the data (associated data,
&gt;    optional).
&gt;
&gt; ** The example code has been aligned to the new specification. I also
&gt;    added an explicit license (actually, public domain dedication under
&gt;    Creative Commons "CC0" -- this seems to be the closest to public
&gt;    domain I can achieve without dying).
&gt;
&gt; -----------------------------------------------------------------------
&gt;
&gt; I have read all the comments made on this list, and I thank everybody
&gt; for such comments; I tried to include most of them, but, unavoidably,
&gt; choices had to be made, because it seems to be a mathematical
&gt; impossibility to comply to all these conflicting requirements.
&gt;
&gt; Notably, Alexander argued for a much more compact format, at the expense
&gt; of readability (depending on who is doing the reading, of course). In
&gt; the specification draft, I chose to concentrate on readability rather
&gt; than compactness. This does not mean that a compact string is not a
&gt; worthwhile goal; only that I cannot achieve readability and compactness
&gt; with a single specification. Maybe another, extra specification should
&gt; be written for the "compactness" case.
&gt;
&gt;
&gt; An important point to be made is that the most extreme compactness can
&gt; be achieved through function-specific rules. For instance, consider
&gt; encoding of a "time cost". This is an integer, and Alexander has done
&gt; some nice research on how to generically encode an integer into a
&gt; sequence of characters. However, a time cost does not need to be able to
&gt; be any integer from 1 to 2^32-1. Consider bcrypt: its number of
&gt; iterations is intrinsically restricted to be equal to 2^x for some
&gt; integer x. This is very artificial (there is no structural requirement
&gt; for the iterations to be a power of two; this is a simple loop counter)
&gt; but it allows for encoding the time cost with a single, short integer.
&gt;
&gt; Forcing the time cost to be a power of 2 may be a bit inflexible (though
&gt; I do not hear people clamouring about it when they use bcrypt). A
&gt; slightly more configurable option is to define the time cost to be
&gt; equal to a*2^b where a = 2 or 3, and b is an integer. If we want to
&gt; encode such a cost over _one_ character, convert the character to a
&gt; 6-bit value x, and say that: t = (2 + (x &amp; 1)) &lt;&lt; (x &gt;&gt; 1)
&gt; This allows 64 possible time costs, scaled from 2 to 3*2^31.
&gt;
&gt; The time cost here is just an example. My point is that very compact
&gt; encodings can be obtained by looking at the semantics of the parameters,
&gt; which are, by definition, specific to each function. Generic rules on
&gt; integer encoding, however smart they are, won't yield the maximum
&gt; possible compactness.
&gt;
&gt;
&gt; With the rules in the specification draft here enclosed, a "typical"
&gt; Argon2i hash string would look something like this:
&gt;
&gt;
&gt;  $argon2i$m=1024,t=50000,p=4$t003K73k/Bomtg8iHN/K4w$KH64roXLeU8kXGNeZXchGBcpmrJXT6NB1fw82bMs5Pk
&gt;
&gt; i.e. a total of 94 characters in that example. Most notably, systems
&gt; that support the "SHA-512 crypt" variant (from glibc) must accept
&gt; strings of length up to 106 characters ("$6$" header, salt up to 16
&gt; characters, an extra "$", then 86 characters of Base64);
&gt; application-allocated buffers should thus already be up to the task. If
&gt; we want Argon2i strings to be still smaller, then I would be tempted to
&gt; reduce the hash output length (128 bits would already be a lot of
&gt; overkill for password authentication; 256 bits seem just wasteful).
&gt;
&gt;
&gt;         --Thomas Pornin
&gt;

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
