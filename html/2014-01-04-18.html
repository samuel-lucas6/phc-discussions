<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] Reworked KDF available on github for feedback: NOELKDF</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="17">[&lt;prev]</a> <a href="19">[next&gt;]</a> <a href="17">[&lt;thread-prev]</a> <a href="20">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;20140104202142.GA4592&#64;openwall.com&gt;
Date: Sun, 5 Jan 2014 00:21:42 +0400
From: Solar Designer &lt;solar&#64;...nwall.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] Reworked KDF available on github for feedback: NOELKDF

On Sat, Jan 04, 2014 at 11:31:49AM -0500, Bill Cox wrote:
&gt; On Sat, Jan 4, 2014 at 1:31 AM, Solar Designer &lt;solar&#64;...nwall.com&gt; wrote:
&gt; &gt; This appears to select the random page index based on the first
&gt; &gt; uint64_t of a page:
&gt; &gt;
&gt; &gt;         // Select a random from page
&gt; &gt;         fromPage = mem + PAGE_LENGTH*(*prevPage % i);
&gt; &gt;
&gt; &gt; and you appear to be computing uint64_t's of a page sequentially, in
&gt; &gt; increasing order.  Thus, the next random page index becomes known
&gt; &gt; almost as soon as you've started processing a page.  This may be
&gt; &gt; intentional (e.g., EARWORM deliberately allows for one-ahead prefetch,
&gt; &gt; but it targets memory bandwidth and doesn't try to be sequential
&gt; &gt; memory-hard), but probably it is not (it provides extra parallelism and
&gt; &gt; allows for much higher latency memory to be used efficiently, which
&gt; &gt; you're not making use of - at least not yet - so it benefits attackers).
&gt; &gt; scrypt uses the last (not the first) element of a block to determine the
&gt; &gt; random index.
&gt; 
&gt; I had the same thought when I wrote that, but then I realized that I can
&gt; compute the last index just as quickly as the first, since they do not
&gt; depend on each other.  Unless I take your advice and reduce parallelism by
&gt; some tunable parameter, there's no way to force the page to be computed
&gt; before the next address is known.

Of course, you should make either both fixes or neither.

&gt; I'm not convinced that reducing this sort of parallelism is desirable, but
&gt; if it is, it should be tunable as you suggest.  An ASIC based attacker is
&gt; going to be memory bandwidth limited almost regardless of our attempts to
&gt; limit parallelism, IMO.  They probably have a bigger serial execution speed
&gt; benefit in a custom ASIC than they have memory bandwidth benefit.

Yet by having the parallelism, you're giving them greater flexibility.

scrypt deliberately tried not to exhaust the memory bandwidth - just get
reasonably close to it (so that much cheaper memory can't be used -
e.g., defeating use of disks instead of RAM).  Then cost to attacker is
then in the die area consumed by the memory times the running time, and
the latter can't be significantly improved due to the sequential nature
of scrypt.

EARWORM reasonably deviates from it, because its memory may be shared
between multiple instances and thus can't be relied upon as the area
factor in area*time.  (The per-instance area is then consumed by memory
access ports and such.)  Thus, for EARWORM it is more important to get
very close to exhausting the memory bandwidth, or even to bump into it.

Now, you also have incentive to get closer to exhausting the memory
bandwidth, because you want to maximize the amount of memory you can
fill in a limited time.

However, by giving attackers extra parallelism (more than you make use
of), you're letting them reduce the time factor in area*time, maybe by
some orders of magnitude (at 16 KB "page" size, the attacker will do up
to 2048 computations in parallel, whereas on a CPU you only do a few).

Your argument is that they'd have to provide more memory bandwidth for
that.  This is sound reasoning.  Yet you become unnecessarily similar to
EARWORM in depending on memory bandwidth _instead_ of on a combination
of die area consumed by memory _and_ bandwidth.

&gt; I think
&gt; we're more likely to hurt ourselves more than an attacker with limits on
&gt; parallel execution.  For example, I know of no recent Android phones or
&gt; Windows laptops that don't have some graphics acceleration ability.
&gt;  Attackers can use GPUs, but so can most users.  GRAM is often faster than
&gt; the CPU's main memory.  We could likely get closer to the attacker's speed
&gt; using our own GPUs by default.  With the multi-threading layout I'm
&gt; currently using, we could run threads on the GPU to max out GDRAM
&gt; simultaneously with running SIMD instructions on the CPU to max out DRAM
&gt; bandwidth.  GDDR5 has amazing bandwidth, so well tuned implementations
&gt; should use this in the future.  If I max out both my GDDR5 and DDR3 memory
&gt; busses, good luck to any attacker trying to beat my speed without paying as
&gt; much as me for RAM.

I agree that having a way to tune settings for much greater instruction
level parallelism could be beneficial.  It's just that having lots of
parallelism available all the time makes your KDF not sequential
memory-hard anymore; it makes it only memory bandwidth bound.

Alexander
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
