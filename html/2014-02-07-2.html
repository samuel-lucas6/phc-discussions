<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] Re: NoelKDF ready for submission</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="1">[&lt;prev]</a> <a href="3">[next&gt;]</a> <a href="3">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;967733941.56086.1391744939458.open-xchange&#64;email.1and1.com&gt;
Date: Thu, 6 Feb 2014 21:48:59 -0600 (CST)
From: Steve Thomas &lt;steve&#64;...tu.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] Re: NoelKDF ready for submission

&gt; On February 4, 2014 at 5:03 PM Bill Cox &lt;waywardgeek&#64;...il.com&gt; wrote:
&gt;
&gt; On Tue, Feb 4, 2014 at 2:01 PM, Steve Thomas &lt;steve&#64;...tu.com&gt; wrote:
&gt; &gt; I found two bugs in your reference code:
&gt; &gt;
&gt; &gt; NoelKDF() Line 102:
&gt; &gt; + numblocks &lt;&lt;= startGarlic;
&gt; &gt; for(i = startGarlic; i &lt;= stopGarlic; i++) {
&gt; &gt;
&gt; &gt; NoelKDF() Line 107:
&gt; &gt; - value += mem[2 * p * numblocks * blocklen + blocklen - 1];
&gt; &gt; + value += mem[(2 * p + 1) * (uint64) numblocks * blocklen - 1];
&gt; &gt; I'm assuming this is a bug since the original is using the last int in the
&gt; &gt; first
&gt; &gt; block. Which is known early on.
&gt;
&gt; Thanks for finding these! I'm using your suggested fix for the 1st
&gt; one, and thinking of just initializing the second loop with value == 1
&gt; like the first. Do you think that would be OK?

Yes, but only because when value is one the first fromAddr is the last block.


&gt; &gt; xorIntoHash() needs to be replaced preferably with a cryptographic hash that
&gt; &gt; uses more than the last hash's size bytes of data. You can reverse a 256 bit
&gt; &gt; non-parallel hash to on average 3 bits of the state in "mem" 7 steps prior
&gt; &gt; through hashBlocks()'s "fromAddr". Also 6 bits from 6 prior, 9 bits from 5
&gt; &gt; prior, 12 bits from 4 prior, ..., 21 bits from 1 prior, and 256 bits from
&gt; &gt; the
&gt; &gt; last block.
&gt;
&gt; Did you notice that wordHash is initialized as the PBKDF2-SHA256 of
&gt; the password and salt?

Yes.


&gt; If I simply XOR-ed the results of the memory
&gt; hashing together, that would be a problem, but since wordHash starts
&gt; out life as indistinguishable from true random data, XOR-ing lower
&gt; quality memory hashes into it cannot damage it's quality.

The quality of random is not in question here.


&gt; I may be unfamiliar with the attack you are referring to, but I don't
&gt; think there is an issue here.

hash = PBKDF2_SHA256(password, salt, 1, hashSize)
...
return hash ^ lastHashSizeBytesOfMem
Make a guess and xor "PBKDF2_SHA256(password, salt, 1, hashSize)" to the hash
you are trying to crack. You now have the assumed last bytes of mem.

Let's say the hash is 256 bits that's 8, 32 bit numbers. We can reverse this
data modulo 4 to 7, 2 bit numbers from "mem[fromAddr+j]":

memHash[i+1] % 4 = (memHash[i] * (mem[prevAddr+blockSize-8+i] | 3) +
mem[fromAddr+blockSize-8+i]) % 4
memHash[i+1] % 4 = (memHash[i] * 3 + mem[fromAddr+blockSize-8+i]) % 4
mem[fromAddr+blockSize-8+i] % 4 = (memHash[i+1] - memHash[i] * 3) % 4

mem[fromAddr+blockSize-8] % 4 = (memHash[1] - memHash[0] * 3) % 4
mem[fromAddr+blockSize-7] % 4 = (memHash[2] - memHash[1] * 3) % 4
mem[fromAddr+blockSize-6] % 4 = (memHash[3] - memHash[2] * 3) % 4
mem[fromAddr+blockSize-5] % 4 = (memHash[4] - memHash[3] * 3) % 4
mem[fromAddr+blockSize-4] % 4 = (memHash[5] - memHash[4] * 3) % 4
mem[fromAddr+blockSize-3] % 4 = (memHash[6] - memHash[5] * 3) % 4
mem[fromAddr+blockSize-2] % 4 = (memHash[7] - memHash[6] * 3) % 4

mem[fromAddr2+blockSize-8] % 4 = (mem[fromAddr+blockSize-7] -
mem[fromAddr+blockSize-8] * 3) % 4
mem[fromAddr2+blockSize-7] % 4 = (mem[fromAddr+blockSize-6] -
mem[fromAddr+blockSize-7] * 3) % 4
mem[fromAddr2+blockSize-6] % 4 = (mem[fromAddr+blockSize-5] -
mem[fromAddr+blockSize-6] * 3) % 4
mem[fromAddr2+blockSize-5] % 4 = (mem[fromAddr+blockSize-4] -
mem[fromAddr+blockSize-5] * 3) % 4
mem[fromAddr2+blockSize-4] % 4 = (mem[fromAddr+blockSize-3] -
mem[fromAddr+blockSize-4] * 3) % 4
mem[fromAddr2+blockSize-3] % 4 = (mem[fromAddr+blockSize-2] -
mem[fromAddr+blockSize-3] * 3) % 4
...

Now do the first half in modulo 4. 1/16 memory plus the extra 31% to 25% memory
reduction and this removes the multiplication. You can do this in AVX2 and get
128 different password guesses running at a time.

Vectorized version of modulo 4 of value = value*3 + mem[fromAddr + i]:
tmp = ((value &amp; 0x5555...) &lt;&lt; 1) ^ value
value = (tmp ^ mem[fromAddr + i]) ^ ((tmp &amp; mem[fromAddr + i] &amp; 0x5555...) &lt;&lt; 1)

Now that we have the first half we just check if we can find this in the first
half:
mem[fromAddr7+blockSize-8] % 4

mem[fromAddr6+blockSize-8] % 4
mem[fromAddr6+blockSize-7] % 4

mem[fromAddr5+blockSize-8] % 4
mem[fromAddr5+blockSize-7] % 4
mem[fromAddr5+blockSize-6] % 4

Keep in mind I'm not sure what the probability of false negatives or false
positive or the optimal number of reversed fromAddr's to check. So this may be
a non-issue.

Also I said you could on average reverse 3 bits, but that's only on the first
reversal. Basically if the least significant bit is 0 then you can get 3 bits
from "mem[fromAddr+j]" if the least significant 2 bits are 00 then 4 bits.
Anyway once you are down to 2 bits you can't get more bits when reversing.
<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
