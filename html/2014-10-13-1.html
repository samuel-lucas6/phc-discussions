<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] What is "basic cryptography" ?</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="../../../2014/10/12/2">[&lt;prev]</a> <a href="2">[next&gt;]</a> <a href="../../../2014/10/12/2">[&lt;thread-prev]</a> <a href="4">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CAFZ8o0PTHmmwjSRRW+aO3XZWBJXtDfKKwwF05HsZnxw9FnETVA&#64;mail.gmail.com&gt;
Date: Mon, 13 Oct 2014 13:27:32 +0200
From: Philip Ittmann &lt;philip.ittmann&#64;...il.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] What is "basic cryptography" ?

Hi Thomas,

I am a PhD student at UCT working with Dr Christine Swart. We've been
following the PHC mailing list on and off for the whole year. I think MAKWA
is really cool, but I still need to do some reading before I can talk with
any authority on its security. I hope it is okay if we reply to your query,
even though I am still getting into the password hashing field.

On 12 October 2014 16:24, Thomas Pornin &lt;pornin&#64;...et.org&gt; wrote:

&gt; In particular, collision resistance implies second-preimage resistance,
&gt; and THAT is good for security proofs, in the following sense: if the
&gt; attacker is given s and h(s, p), and is challenged with finding a
&gt; password p' such that h(s, p') = h(s, p) (that is the normal setup when
&gt; considering an authentication server), then second-preimage resistance
&gt; means that if the attacker succeeds, then he found p' = p; otherwise,
&gt; that would contradict second-preimage resistance. So far so good: if
&gt; second-preimage resistance can be proven (and proving collision
&gt; resistance implies proving second-preimage resistance), then we have
&gt; shown that if an attacker finds a matching password, then he found _the_
&gt; password, meaning that no password entropy was lost in the process: the
&gt; space of potential passwords, already quite small (that's the problem
&gt; with passwords), is not unduly shrunk through some misbehaving of the
&gt; function.
&gt;

I am not sure this argument as is makes sense -- in particular second
pre-image resistance normally assumes you already have the original
password p. The argument would make more sense if it used pre-image
resistance.

If so, does the following logic appeal to your needs at all? Suppose you
find a pre-image p' such that h(s,p') = h(s,p), then what is the
probability that p' is a 'natural' password (i.e., in the password space
P)? If #P = 2^30, and the hash has 256 bit output, then finding another
'natural' password which collides with the hash is akin to rolling a 2^256
sided dice 2^30 times and hoping to roll the value h(s,p). Then, Pr[h(s,p)
is rolled atleast once] ~= 1 - e^(-2^30/2^257) ~= 0. So, the probability of
finding a 'natural' password p' != p which collides with p is really low.
This is assuming that h(s, ) follows a uniform distribution over all
possible inputs, which may be an invalid assumption.

I think what you want to show is essentially that it's very unlikely that
there are two passwords p and p' with the same hash, and the probabilistic
argument supports this as the case.

You can't really prove it using second preimage resistance though, because
second preimage resistance doesn't say there *aren't* two passwords p and
p' with the same hash -- it just says that if there are, then given one of
them it is computationally infeasible to find the other.

In the unlikely even that there *are *two such passwords p and p', then
there's nothing really to distinguish them from the attacker's point of
view -- he doesn't know either of them to start, and they'll both work
equally well as passwords, so there's no way for him to know which one
actually was Alice's password (beyond the a priori probability distribution
on the passwords) -- so there's no way to conclude that *if* he finds one
of them then it must be p.  (If *Alice* finds p', knowing p, then *that* would
violate second pre-image resistance.)

With password hashing, things are not as easy. The space of possible
&gt; inputs will be a lot smaller, and quite smaller than the apparent size
&gt; of the output space. For instance, a password hashing function may
&gt; produce a 128-bit value, but since there are much fewer than 2^128
&gt; possible passwords (realistically), then not all 128-bit outputs are
&gt; actually possible. In any case, brute force on the input is assumed
&gt; to work (the input is a password). So I could try something like this:
&gt;
&gt;    Password-hashing function h() will be said to be preimage resistant
&gt;    if it is not feasible, given s and h(s, p) for an unknown p chosen
&gt;    randomly and uniformly in space P, to find p' such that
&gt;    h(s, p) = h(s, p') with average cost less than #P/2 the cost of
&gt;    evaluating h().
&gt;
&gt; I am not satisfied with that definition for the two following reasons:
&gt;
&gt;  - This depends on the space of potential passwords. For the definition
&gt;    to be useful, it must hold for all spaces of a given size, and not
&gt;    just "on average". That is, the "average cost of #P/2 evaluations"
&gt;    must be understood as "over all p in P for a single, given P". I
&gt;    fear that such a definition may be defeated by anomalous spaces of
&gt;    passwords that are not realistic in any way.
&gt;
&gt;  - This definition includes the cost of evaluating h(), i.e. it
&gt;    postulates the lack of any shortcut. Thus, it fails at separating
&gt;    cryptography from engineering.
&gt;
&gt;
I think I understand your concerns with respect to the non-uniformity of
the password space and how that would affect the distribution of possible
hash values. But I was wondering if this concern is not dealt with by using
a uniformly selected  random salt for each password? Wouldn't this allow
the entire hash output space to be admitted as possible hash values? I
understand if you fix the salt, that things get sticky, but is that really
a concern?


&gt; Does anybody here has an idea on the subject ? Or maybe a reference to
&gt; some existing published work that already covers these questions ?
&gt;
&gt; The Rogaway and Shrimpton paper which Daniel linked to does look at all
these considerations (except maybe the non-uniformity of the message
space?).


&gt;
&gt;         --Thomas Pornin
&gt;

I hope the email helps. I am really enjoying sinking my teeth in the PHC.

Best wishes,
Philip Ittmann

<span style="font-family: times;"><strong>Content of type "</strong>text/html<strong>" skipped</strong></span>
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
