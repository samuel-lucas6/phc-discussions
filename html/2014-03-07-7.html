<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] TigerKDF paper and code ready for review</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="6">[&lt;prev]</a> <a href="8">[next&gt;]</a> <a href="4">[&lt;thread-prev]</a> <a href="../../../2014/03/08/1">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;CAOLP8p6MJwZownaTJjY6o2g7dUFPh4w1JSdzfSMO1vZk6gpKzQ&#64;mail.gmail.com&gt;
Date: Fri, 7 Mar 2014 10:50:48 -0500
From: Bill Cox &lt;waywardgeek&#64;...il.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] TigerKDF paper and code ready for review

On Thu, Mar 6, 2014 at 9:45 PM, Solar Designer &lt;solar&#64;...nwall.com&gt; wrote:
&gt; On Thu, Mar 06, 2014 at 07:12:27PM -0500, Bill Cox wrote:
&gt;&gt; I still have to do a bit of work on the paper, but it's nearly ready:
&gt;&gt;
&gt;&gt;     <a href="http://waywardgeek.net/TigerKDF.pdf" rel="nofollow">http://waywardgeek.net/TigerKDF.pdf</a>
&gt;&gt;
&gt;&gt; The code is on github and can be checked out with:
&gt;&gt;
&gt;&gt;     git clone git://github.com/waywardgeek/tigerkdf.git
&gt;&gt;
&gt;&gt; I suspect TigerKDF, my 3rd major rewrite in 2 months, may be
&gt;&gt; competitive.
&gt;
&gt; I think it is competitive.
&gt;
&gt; I didn't fully read the paper yet, but here's some criticism, which I
&gt; hope might make TigerKDF and/or the paper better:
&gt;
&gt;&gt; * Fills and hashes memory rapidly - 1/2 as fast as memmove
&gt;
&gt; Cool.  Somehow in the paper you give GB/s figures for scrypt when
&gt; running a single thread only.  Why don't you mention that when running
&gt; as many threads as there are logical CPUs, meaning 8 on a currently
&gt; typical quad-core CPU, optimized scrypt code (such as in escrypt, and I
&gt; think also floodyberry's) processes 8 GiB in 2.4 seconds, which means
&gt; 6.7 GiB/s (considering that memory is first written and then read back),
&gt; or &gt;1/4 of theoretical peak memory bandwidth on those machines?  In fact,
&gt; a trivial change to scrypt - reducing the Salsa20 round count to 2 -
&gt; makes scrypt faster yet, perhaps as fast as TigerKDF when you run enough
&gt; threads.  This may well be a baseline to compete against, since you need
&gt; to justify the major differences vs. that 3-line change (e.g., in
&gt; escrypt's crypto_scrypt-sse.c it's a matter of deleting 3
&gt; SALSA20_2ROUNDS lines, leaving just one).

Thanks for this feedback!  I'll update Scrypt hashing speeds for
multiple threads.  I'm afraid I thought the p value wasn't working,
since I didn't realize increasing p increased memory -- D'oh!  You set
me straight on that the other day, but it didn't occur to me to go
update the benchmarks.

I need to overhaul the benchmarks.  I'm still noodling what to report.
 Should I drop direct Scrypt numbers and only report the improved
Escrypt numbers, or list both?  I feel bad already about listing my
Catena numbers - these aren't even official entries yet, but I wanted
to justify the need for the unpredictable second loop, and the Catena
benchmarks are useful for that.  Also, I only want to list numbers for
the case where all else is equal - last time I substituted the exact
same hash function into Catena that I used in NoelKDF, and I should
probably do the same this time and update Catena to use the SSE/AVX2
optimized memory hash function I use.

I'm also not sure I'm measuring the critical parameters correctly -
for example Catena uses 1/4th the memory compared to it's DAG size,
but it fills memory in the first 1/6th of the runtime (1st write pass
out of a total of 6 read/write passes, assuming memory bandwidth
limited), meaning it has an average memory usage of 11/12ths the peak,
while TigerKDF has 1/2 the average relative to peak, and Scrypt has
3/4ths (with the naive assumption that every pass has equal speed).
Maybe I should report both average and peak time*memory costs?  Also,
is it fair to only list single-thread numbers for Catena when it is
still possible to use pepper?  Single-thread is probably the most
important case, but how do we highlight the advantage of a
multi-threaded implementation, especially since we're hashing memory
between threads?  In reality, most implementations will probably use p
&gt; 1 with our KDFs, but with Catena, they'll mostly not use pepper.

One of my favorite changes to Scrypt would be reducing it from
Salsa20/8 to Salsa20/2.  If it were me, I'd make the default Escrypt
hashing Salsa20/2 or faster (ChaCha/Blake2 based).  Do you mind if I
make that 3-line change to your Escrypt version and add those numbers
to the table?  I think there's value in promoting this change for
Scrypt, in addition to contrasting it to TigerKDF benchmarks.

Also, I should probably list TigerKDF numbers without SSE enabled as
well.  I currently haven't implemented the optimized non-SEE version,
but it wont be too hard.

Anyway, your feedback is especially helpful.  If I'm submitting dumb
data, I'd rather hear about it now.

&gt; In terms of memory bandwidth, TigerKDF may have advantage in that it
&gt; achieves high memory bandwidth usage at lower thread counts, which means
&gt; at lower parallelism.  As we know, excessive parallelism benefits some
&gt; attackers, so this property of TigerKDF may be good.  You may brag about
&gt; that. :-)  On the other hand, bumping into memory bandwidth way sooner
&gt; than we've put all of the suitable CPU execution units to use makes us
&gt; more vulnerable to attacks on _some_ future CPU-based systems where
&gt; balance _might_ be shifted towards higher memory bandwidth (then the
&gt; attacker will be able to run more instances in parallel, for different
&gt; candidate passwords).

Frankly, I'm not as skilled at designing code for so many different
cases.  For example, I followed your thread about making use of
multiple CPU multipliers, and I understand the potential benefit, but
I'm sticking to just 1.  My head will explode otherwise.

I'm also trying to figure out how to best auto-select parameters.
Both repetitions and number of multiplies effect runtime, but for most
users, I'd like to let them just specify a timeCost parameter.  The
default "full" interface just has a timeCost right now.  Maybe I
should add an extended interface.

&gt; I think it is best to stay balanced in terms of all of: memory bandwidth
&gt; usage, CPU usage, and multiply time hardness.  e.g. bumping into one of
&gt; these while using 80% of the other two is great, whereas bumping into one
&gt; of these while using &lt;50% of one or both of the other two is not as good.
&gt; And yes, this may require tunable parameters (you might already have
&gt; enough of them to allow for such tuning).

That is the best case.  My current interface just gives the user
memCost, timeCost, and parallelism.  That is enough to balance total
memory (memCost), compute time (timeCost), and # of CPUs
(parallelism), but not enough to balance bandwidth at the same time.
I'm one parameter short.  Splitting timeCost into separate multiplies
and repetitions works, though.

There's also an issue with blocksize.  For only 1 repetition and large
memory, I've found 16KiB to be superior to 4KiB, but some CPUs may
have only 4KiB or 8KiB L1 caches, and I'm tempted to reduce the block
size down to 4KiB.  If I do, I probably wont make it adjustable, since
the performance penalty at 4KiB block sizes on high end machines isn't
too bad.

However, I do adjust the block size and sub-block size downwards if
low memory is used.  Currently, if there are less than 256 blocks per
thread, I decrease the block size, all the way down to 32 bytes for a
1KiB hash (which is what memCost == 0 means).

&gt;&gt; * Provides strong defense against GPU, FPGA, and ASIC attacks
&gt;
&gt; I'm afraid the defense against GPUs is still not as strong as you claim
&gt; it is.  You compare TigerKDF's 64-byte random lookups against bcrypt's
&gt; 16-byte lookups - but bcrypt actually does 4 independent 4-byte lookups
&gt; per round.  This difference is subtle in that the 4 lookups may proceed
&gt; in parallel, but it is crucial in requiring use of local memory for
&gt; optimal performance on current GPUs, vs. use of off-chip memory (where
&gt; entire cache lines would be fetched, which is too wasteful for 4-byte
&gt; lookups, but is 4x less inefficient for 16-byte ones).  Specifically,
&gt; bcrypt $2a$05 cracking using local memory runs at ~4k c/s on HD 7970
&gt; (925 MHz), whereas using global memory it slows down to ~2k c/s.  From
&gt; these numbers, I'd expect ~8k c/s (4 times the ~2k c/s it gets with
&gt; global memory) if it made 16-byte lookups instead of 4x 4-byte lookups.
&gt; In other words, it'd be roughly twice faster per-chip on that GPU than
&gt; on its contemporary quad-core CPUs (which deliver ~5k c/s).  Increasing
&gt; this further to 64 bytes would give ~32k c/s, or 8 times faster than
&gt; original, and the increase from 4 KiB to 32 KiB that you claim should
&gt; prevent this actually would not, because at these lookup sizes we're
&gt; talking global memory, which we have lots of (compared to either 4 KiB
&gt; or 32 KiB).  In fact, this gets close to and is consistent with
&gt; Litecoin's 128-byte lookups, which also use global memory fine.  Yes, in
&gt; Litecoin the lookup results are not needed as soon, but when we're using
&gt; global memory this difference is unimportant (as long as we have enough
&gt; extra global memory), because the latencies are hidden by having lots of
&gt; extra concurrent instances.
&gt;
&gt; Now, I understand that it's wasteful to do lookups smaller than 16 bytes
&gt; e.g. on Sandy Bridge and better (where we can do two 16-byte lookups
&gt; from L1 cache per cycle, or only the same number of smaller lookups).
&gt; Good news: to be as GPU-resistant as bcrypt, you don't need your lookups
&gt; to be as small as bcrypt's.  Rather, you need them to be as rapid as
&gt; bcrypt's, with results required as soon as bcrypt does, and with no more
&gt; parallelism than bcrypt has.  (These last two conditions are actually
&gt; one.)  It is not a problem per se if an implementation turns out to be
&gt; more efficient using global rather than local memory, as long as the
&gt; accesses are as rapid as bcrypt's.  Those conditions imply that it won't
&gt; run faster than bcrypt, using either type of memory.  So your comparison
&gt; of GPU resistance vs. bcrypt's compares the wrong thing.  Now, if your
&gt; random lookup results are not required as soon as bcrypt does require
&gt; them (meaning you have more parallelism in one instance), you may in
&gt; fact compensate for that by making the random lookups arena larger.

Thanks for that description.  I was definitely confused about how
Bcrypt limits GPUs.  I'm going to have to noodle some more on this.

One concern I have is the possibility that chips with many CPUs and
tiny caches are coming in the near future.  I see nothing stopping
cheap 28nm or lower 256 core chips with 4KiB local caches from being
built, with each CPU running at 1GHz or more.  An array of chips like
that on a board would tear through Bcrypt hashes, wouldn't it?

I think I should move my repetitions parameter to the outer loop so
that if I repeat N times, it repeats the entire memory hash N times
rather than rehashing the same blocks N times before moving on to the
next one.  Moving computations out of small local memories seems to be
a decent defense against chips with more parallelism but small local
memories.

&gt; BTW, why do you mention 32 KiB there?  Your random lookups arena is
&gt; only 16 KiB, and you can't make it larger than that on current CPUs with
&gt; 32 KiB L1d cache and 2 hardware threads/core, without incurring much
&gt; extra L1 cache thrashing.  TigerKDF's total memory usage is irrelevant.
&gt; In other words, you may compensate for up to 4x more latency tolerance or
&gt; parallelism than bcrypt has.  But you can't necessarily compensate for
&gt; less frequent lookups (make them 2x+ less frequent than bcrypt's, and
&gt; use of global memory becomes beneficial on HD 7970, regardless of lookup
&gt; size).  I am fighting with the same problem in escrypt.  It's tough,
&gt; especially when we consider running on smaller SIMD-less CPUs with
&gt; settings that are also good for SIMD-enabled CPUs.  I'm afraid this
&gt; combination of desirable properties - common settings for SIMD-less and
&gt; SIMD-enabled (up to certain sane vector width), yet GPU resistance no
&gt; worse than bcrypt's - is just not possible.  Have to tune for SIMD-less
&gt; and SIMD-enabled separately if we don't accept giving up on having GPU
&gt; resistance no worse than bcrypt's.

I'm not trying to have resistance as strong as Bcrypt at 4KiB, but I
would like the resistance to be stronger for a small size, preferably
much less than 1MiB.  Any 4KiB hashing algorithm is highly
parallelizable on a custom ASIC, and with high CPU count generic
processors coming, I doubt anyone should count on a 4KiB hash being
secure.  Even 1MiB fast cache memories can likely integrate somewhere
between 16 to 64 on a reasonable sized 28nm ASIC, and I don't even
want to think about how many 4KiB cores we could integrate.

At least with AVX2 on Haswell, I would be surprised if Bcrypt's inner
loop were faster, so for hashing out of just L1 cache, I'm probably
good on that platform vs current GPUs.  As you say, it's the older
CPUs that are problematic for GPU defense.

&gt; Another aspect (I had mentioned before but didn't emphasize enough) is
&gt; that while you need something like a 16 KiB small random lookup arena
&gt; for the anti-GPU lookups, it is excessive for the higher-level scrypt-like
&gt; lookups.  I think it is actually undesirable to make these higher-level
&gt; lookups that large.  scrypt paper recommends r=8 for a reason: just high
&gt; enough to amortize the overhead of TLB misses.  In my testing, I mostly
&gt; use values of r between 5 and 8 (thus, 640 to 1024 bytes).  Yes, I could
&gt; get slightly higher memory bandwidth with higher r, but then there's
&gt; less of a dependency on the memory being the fairly low latency RAM that
&gt; we have in typical defender's systems.  An attacker would gain extra
&gt; flexibility in using other types of memory, including e.g. SSDs or
&gt; combined RAM of multiple machines.  I don't know how much of an issue
&gt; this is going to be in practice (might be a non-issue, I admit).  I think
&gt; this issue is more relevant when there's a ROM lookup table that might
&gt; not fit in a certain attack node's RAM, so more relevant to some use
&gt; cases for escrypt than to TigerKDF.

I'm thinking of reducing the default block size to either 4KiB or
8KiB.  I think you'll find that with Salsa20/2 hashing, that 1KiB
Scrypt hashing is significantly slower than 4KiB hashing.  Of course,
I am working with two sticks of very fast 4GiB RAM, probably faster
than most defenders.  I'll do some benchmarks on your Sandy Bridge and
Haswell machines to help pick a better default size.

&gt;&gt; 8. Inter-thread memory hashing to thwart TMTOs (Solar Designer)
&gt;
&gt; In another message, you mentioned you introduced multiple thread syncs
&gt; per hash computation.  Why?  I think it is best to have just one more
&gt; than scrypt does (so 2 instead of 1).  Each threads sync is potentially a
&gt; huge performance loss when the system is under other load (overbooked),
&gt; which is a common occurrence on servers (OK, perhaps they should fully
&gt; avoid "our" threads anyway, using solely their own coming from nearly
&gt; concurrent authentication attempts).

Doing several thread syncs is the most recent enhancement I've made.
In NoelKDF, I only did one in the middle and one at the end, and only
the first half of memory was accessed by multiple threads.  Perhaps
the additional complexity is not worth it, but without more sync
points, an attacker has fewer TMTO options.  For example, if he can
fit 1/2 the memory, but not all of it, he can fill the first half and
then run the second half threads sequentially.  This results in a
higher time*memory cost though.

What do you think?  Should I revert back to just 2 sync point?

&gt; I am sorry for providing solely the criticism.  I actually like many
&gt; things about TigerKDF, naturally. ;-)  It's just that saying "I like
&gt; this" about specific things is probably less helpful (unless you were
&gt; going to drop any of the good things, which I think you are not).
&gt;
&gt; Thanks!
&gt;
&gt; Alexander

This is great feedback!  I really appreciate it.

Bill
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
