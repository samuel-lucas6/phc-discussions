<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
body { font-size: 16px; }
.cal_brief { text-align: center; }
.cal_brief td:first-child { background: inherit; }
.cal_brief td { background: #ccc; width: 5ex; padding: 2px; }
.cal_big { text-align: center; padding: 0; margin: 0; }
.cal_big td { padding: 0 2px; }
.cal_mon { text-align: center; }
.cal_mon th { font-size: small; padding: 0; margin: 0; }
.cal_mon td { background: #ccc; width: 5ex; height: 1.5em;
	padding: 2px; text-align: right; }
.cal_mon td[colspan] { background: inherit; }
.cal_mon sup { color: #F0F0F0; text-align: left; float: left;
	margin-top: -2pt; font-weight: bold; }
.cal_mon a { text-align: right; margin-left: -4em; float: right; }
</style>

<title>phc-discussions - Re: [PHC] Specification of a modular crypt format</title>


</head>

<BODY bgcolor="#E0E0E0" text="black" link="blue" alink="red" vlink="navy">



<TABLE bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="39%">
<A HREF="http://lists.openwall.net">lists.openwall.net</A>
<TD width="1%" rowspan="3">&nbsp;
<TD width="60%" align="right" rowspan="3">
<A HREF="/">lists</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/announce/">announce</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-users/">owl-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/owl-dev/">owl-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-users/">john-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/john-dev/">john-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwdqc-users/">passwdqc-users</A>&nbsp;
<A HREF="http://www.openwall.com/lists/yescrypt/">yescrypt</A>&nbsp;
<A HREF="http://www.openwall.com/lists/popa3d-users/">popa3d-users</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/oss-security/">oss-security</A>&nbsp;
<A HREF="http://www.openwall.com/lists/kernel-hardening/">kernel-hardening</A>&nbsp;
<A HREF="http://www.openwall.com/lists/musl/">musl</A>&nbsp;
<A HREF="http://www.openwall.com/lists/sabotage/">sabotage</A>&nbsp;
<A HREF="http://www.openwall.com/lists/tlsify/">tlsify</A>&nbsp;
<A HREF="http://www.openwall.com/lists/passwords/">passwords</A>&nbsp;
/&nbsp;
<A HREF="http://www.openwall.com/lists/crypt-dev/">crypt-dev</A>&nbsp;
<A HREF="http://www.openwall.com/lists/xvendor/">xvendor</A>&nbsp;
/&nbsp;
<A HREF="/bugtraq/">Bugtraq</A>&nbsp;
<A HREF="/full-disclosure/">Full-Disclosure</A>&nbsp;
<A HREF="/linux-kernel/">linux-kernel</A>&nbsp;
linux-<A HREF="/netdev/">netdev</A>&nbsp;
<A HREF="/linux-ext4/">linux-ext4</A>&nbsp;
<a href="/linux-hardening/">linux-hardening</a>&nbsp;
<a href="/linux-cve-announce/">linux-cve-announce</a>&nbsp;
<a href="/phc-discussions/">PHC</a>&nbsp;
<TR><TD>
<DIV><FONT SIZE="-2"><I>Open Source and information security mailing list archives</I></FONT></DIV>
<TR><TD>&nbsp;
</TABLE>

<TABLE bgcolor="#B4D0DC" width="100%" border="0" cellspacing="0" cellpadding="1">
<TR><TD>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2">
<TR><TD bgcolor="#ECF8FF">

<a href="https://hashsuite.openwall.net/android">
Hash Suite for Android: free password hash cracker in your pocket</a>


</TABLE>
</TABLE>


<a href="7">[&lt;prev]</a> <a href="9">[next&gt;]</a> <a href="5">[&lt;thread-prev]</a> <a href="9">[thread-next&gt;]</a> <a href=".">[day]</a> <a href="..">[month]</a> <a href="../..">[year]</a> <a href="../../..">[list]</a>
<pre style="white-space: pre-wrap">
Message-ID: &lt;5608752E.4060400&#64;openwall.com&gt;
Date: Mon, 28 Sep 2015 02:01:02 +0300
From: Alexander Cherepanov &lt;ch3root&#64;...nwall.com&gt;
To: discussions&#64;...sword-hashing.net
Subject: Re: [PHC] Specification of a modular crypt format

On 2015-09-14 19:05, Hugo Landau wrote:
&gt;&gt; I am not using standard Base64 (RFC 4648) for encoding of binary
&gt;&gt; strings, but the "traditional" variant which is already used in some
&gt;&gt; existing hash strings, for the following reasons:
&gt;
&gt; I'm not convinced by this rationale. Firstly, I'm not aware of any
&gt; base64 functionality provided by programming language standard libraries
&gt; which does line wrapping, etc. The world seems to agree that 'base64'
&gt; has come to mean a certain thing, distinct from 'PEM base64' etc.

In Perl, encode_base64 from the MIME::Base64 module inserts \n by 
default but it's easy to turn off.

&gt; While it's true that RFC 4648 base64 generates padding, this can easily
&gt; be stripped.

Well, you can also fix alphabet used by base64 with a simple 
substitution by a table, like piping through `tr ./0-9A-Za-z A-Za-z0-9+/`.

&gt; So this doesn't seem like a justification for using a
&gt; different 'alphabet' (and IIRC endianness of encoding). In other words,
&gt; this would be a gratuitous difference almost for the sake of
&gt; incompatibility. It seems like an overreaction to use something very
&gt; different because the more common choice is slightly off (but easily
&gt; rectified).
&gt;
&gt; While it's true that existing crypt() implementations and their base64
&gt; implementation is widespread, RFC 4648 base64 is more prevalent still.
&gt; And consider that the most pressing case for modern password hashing is
&gt; probably not in /etc/shadow, but in the user databases of large, popular
&gt; websites. Developers in this circumstance (or, preferably, people
&gt; developing password hashing libraries) will have RFC 4648 base64
&gt; libraries available to them, but if they have to use crypt() base64 they
&gt; may have to implement it themselves, which creates the risk that they
&gt; will implement it in a subtly buggy or broken fashion.

While I like standard base64 (so that I can easily pipe it through 
base64(1) or openssl base64) my main concern with base64 is validation 
of input on decoding. I've just tested php, perl and python2/3. None of 
them fails on non-alphabet characters by default! In perl, you cannot 
force strict parsing. In php, you can (with an additional parameter to 
decoding function) but it will ignore \n even inside input string. In 
python3, you can too but in my experiment it ignored e.g. superfluous 
"==\n" appended to the end. And in python2, base64.b64decode is 
documented as raising an exception on non-alphabet characters but it 
doesn't do it for me.

And surely, none of them checked that trailing bits are zero if the last 
group is incomplete.

-- 
Alexander Cherepanov
</pre>
<p><a href="https://www.openwall.com/blists/">Powered by blists</a> - <a href="https://lists.openwall.net">more mailing lists</a>


<p>




</body>
</html>
